<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web前端性能优化——提高页面加载速度</title>
      <link href="/2018/11/18/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
      <url>/2018/11/18/Web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E6%8F%90%E9%AB%98%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>前言： </p><p>在同样的网络环境下，两个同样能满足你的需求的网站，一个“Duang”的一下就加载出来了，一个纠结了半天才出来，你会选择哪个？研究表明：用户最满意的打开网页时间是2-5秒，如果等待超过10秒，99%的用户会关闭这个网页。也许这样讲，各位还不会有太多感触，接下来我列举一组数据：Google 网站访问速度每慢400ms就导致用户搜索请 求下降0.59%; Amazon 每增加100ms网站延迟将导致收入下降1%;雅虎如果有400ms延迟会导致流量下降5-9%。网站的加载速度严重影响了用户体验，也决定了这个网站的生死存亡。</p><p>可能有人会说：网站的性能是后端工程师的事情，与前端并无多大关系。我只能说，too young too simple。事实上，只有10%~20%的最终用户响应时间是用在从 Web 服务器获取 HTML 文档并传送到浏览器的，那剩余的时间去哪儿了？来瞄一下性能黄金法则：</p><p>只有10%~20%的最终用户响应时间花在了下载HTML文档上。其余的80%~90%时间花在了下载页面中的所有组件上。</p><p>接下来我们将研究一下前端攻城狮如何来提高页面的加载速度。</p><h2 id="减少-HTTP-请求"><a href="#减少-HTTP-请求" class="headerlink" title="减少 HTTP 请求"></a>减少 HTTP 请求</h2><p>上面说到80%~90%时间花在了下载页面中的所有组件进行的 HTTP请求上。因此，改善响应时间最简单的途径就是减少 HTTP请求的数量。</p><h3 id="图片地图："><a href="#图片地图：" class="headerlink" title="图片地图："></a>图片地图：</h3><p>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个 HTTP 请求。然而，使用一个图片地图可以提高效率，这样就只需要一个 HTTP 请求。</p><p><img src="https://images2015.cnblogs.com/blog/861963/201603/861963-20160317164616318-1916945778.png" alt></p><p>服务器端图片地图：将所有点击提交到同一个 url，同时提交用户点击的 x、y 坐标，服务器端根据坐标映射响应</p><p>客户端图片地图：直接将点击映射到操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;planets.jpg&quot; border=&quot;0&quot; usemap=&quot;#planetmap&quot; alt=&quot;Planets&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt;</span><br><span class="line">     &lt;area shape=&quot;rect&quot; coords=&quot;180,139,14&quot; href =&quot;venus.html&quot; alt=&quot;Venus&quot; /&gt;</span><br><span class="line">     &lt;area shape=&quot;rect&quot; coords=&quot;129,161,10&quot; href =&quot;mercur.html&quot; alt=&quot;Mercury&quot; /&gt;</span><br><span class="line">     &lt;area shape=&quot;rect&quot; coords=&quot;0,0,110,260&quot; href =&quot;sun.html&quot; alt=&quot;Sun&quot; /&gt;</span><br><span class="line">     &lt;area shape=&quot;rect&quot; coords=&quot;140,0,110,260&quot; href =&quot;star.html&quot; alt=&quot;Sun&quot; /&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>使用图片地图的缺点：指定坐标区域时，矩形或圆形比较容易指定，而其它形状手工指定比较难</p><h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>CSS Sprites 直译过来就是 CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，然后通过 CSS 的一些技术布局到网页上。特别是图片特别多的网站，如果能用 CSS Sprites 降低图片数量，带来的将是速度的提升。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.nav &#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    border: 1px solid #000;</span><br><span class="line">    background-image: url(&apos;E:/1.png&apos;);</span><br><span class="line">&#125;</span><br><span class="line">#image1 &#123;</span><br><span class="line">        background-position: 0 0;</span><br><span class="line">&#125;</span><br><span class="line">#image2 &#123;</span><br><span class="line">        background-position: -95px 0;</span><br><span class="line">&#125;</span><br><span class="line">#image3 &#123;</span><br><span class="line">        background-position: -185px 0;</span><br><span class="line">&#125;</span><br><span class="line">#image4 &#123;</span><br><span class="line">        background-position: -275px 0;</span><br><span class="line">&#125;</span><br><span class="line">#image5 &#123;</span><br><span class="line">        background-position: -366px -3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span id=&quot;image1&quot; class=&quot;nav&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span id=&quot;image2&quot; class=&quot;nav&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span id=&quot;image3&quot; class=&quot;nav&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span id=&quot;image4&quot; class=&quot;nav&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span id=&quot;image5&quot; class=&quot;nav&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://images2015.cnblogs.com/blog/861963/201603/861963-20160317164616318-1916945778.png" alt></p><p>PS：使用 CSS Sprites 还有可能降低下载量，可能大家会认为合并后的图片会比分离图片的总和要大，因为还有可能会附加空白区域。实际上，合并后的图片会比分离的图片总和要小，因为它降低了图片自身的开销，譬如颜色表、格式信息等。</p><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少 http 请求，字体图标还可以通过 CSS 来设置颜色、大小等样式，何乐而不为。</p><p>合并脚本 和样式表</p><p>将多个样式表或者脚本文件合并到一个文件中，可以减少 HTTP 请求的数量从而缩短效应时间。</p><p>然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。</p><h2 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h2><p>如果应用程序 Web 服务器离用户更近，那么一个 HTTP请求的响应时间将缩短。另一方面，如果组件 Web 服务器离用户更近，则多个 HTTP请求的响应时间将缩短。</p><p>CDN（内容发布网络）是一组分布在多个不同地理位置的 Web 服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN 可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。</p><p>CDN 还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和 Web 流量峰值压力。</p><p>CDN 的缺点：</p><p>1、响应时间可能会受到其他网站流量的影响。CDN 服务提供商在其所有客户之间共享 Web 服务器组。</p><p>2、如果 CDN 服务质量下降了，那么你的工作质量也将下降</p><p>3、无法直接控制组件服务器</p><h2 id="添加-Expires-头"><a href="#添加-Expires-头" class="headerlink" title="添加 Expires 头"></a>添加 Expires 头</h2><p>页面的初次访问者会进行很多 HTTP请求，但是通过使用一个长久的 Expires 头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的 HTPP请求，从而提高加载速度。</p><p>Web 服务器通过 Expires 头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：</p><p>Expires: Fri, 18 Mar 2016 07:41:53 GMT</p><p>Expires 缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查</p><p>HTTP1.1中引入 Cache-Control 来克服 Expires 头的限制，使用 max-age 指定组件被缓存多久。</p><p>Cache-Control： max-age=12345600</p><p>若同时制定 Cache-Control 和 Expires，则 max-age 将覆盖 Expires 头</p><h2 id="压缩组件"><a href="#压缩组件" class="headerlink" title="压缩组件"></a>压缩组件</h2><p>从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来表示对压缩的支持</p><p>Accept-Encoding: gzip,deflate</p><p>如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web 服务器通过响应中的 Content-Encoding 来通知 Web 客户端。</p><p>Content-Encoding: gzip</p><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>当浏览器通过代理来发送请求时，情况会不一样。假设针对某个 URL 发送到代理的第一个请求来自于一个不支持 gzip 的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个 url，来自于一个支持 gzip 的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持 gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持 gzip。</p><p>解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。</p><p>vary: Accept-Encoding</p><h2 id="将样式表放在头部"><a href="#将样式表放在头部" class="headerlink" title="将样式表放在头部"></a>将样式表放在头部</h2><p>首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。</p><p>我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。</p><p>将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西</p><h2 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h2><p>更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。</p><p>js 的下载和执行会阻塞 Dom 树的构建（严谨地说是中断了 Dom 树的更新），所以 script 标签放在首屏范围内的 HTML 代码段里会截断首屏的内容。</p><p>下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。</p><h2 id="使用外部的-JavaScript-和-CSS"><a href="#使用外部的-JavaScript-和-CSS" class="headerlink" title="使用外部的 JavaScript 和 CSS"></a>使用外部的 JavaScript 和 CSS</h2><p>内联脚本或者样式可以减少 HTTP 请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而 HTML 文档的大小减小，从而提高加载速度。</p><p>影响因素：</p><p>1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。</p><p>2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。</p><h3 id="加载后下载"><a href="#加载后下载" class="headerlink" title="加载后下载"></a>加载后下载</h3><p>有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成后动态加载外部组件，以便用户接下来的访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function doOnload() &#123;</span><br><span class="line">    setTimeout(&quot;downloadFile()&quot;,1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = doOnload;</span><br><span class="line"></span><br><span class="line">function downloadFile() &#123;</span><br><span class="line">    downloadCss(&quot;http://abc.com/css/a.css&quot;);</span><br><span class="line">    downloadJS(&quot;http://abc.com/js/a.js&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function downloadCss(url) &#123;</span><br><span class="line">    var ele = document.createElement(&apos;link&apos;);</span><br><span class="line">    ele.rel = &quot;stylesheet&quot;;</span><br><span class="line">    ele.type = &quot;text/css&quot;;</span><br><span class="line">    ele.href = url;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function downloadJS(url) &#123;</span><br><span class="line">    var ele = document.createElement(&apos;script&apos;);</span><br><span class="line">    ele.src = url;</span><br><span class="line">    document.body.appendChild(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该页面中，JavaScript 和 CSS 被加载两次（内联和外部）。要使其正常工作，必须处理双重定义。将这些组件放到一个不可见的 IFrame 中是一个比较好的解决方式。</p><h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>当我们在浏览器的地址栏输入网址（譬如： <a href="http://www.linux178.com）" target="_blank" rel="noopener">www.linux178.com）</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p><p>域名解析 –&gt; 发起 TCP 的 3 次握手 –&gt; 建立 TCP 连接后发起 http 请求 –&gt; 服务器响应 http 请求，浏览器得到 html 代码 –&gt; 浏览器解析 html 代码，并请求 html 代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>域名解析是页面加载的第一步，那么域名是如何解析的呢？以 Chrome 为例：</p><p>1.Chrome 浏览器 会首先搜索浏览器自身的 DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。<br>注：我们怎么查看 Chrome 自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</p><p>2.如果浏览器自身的缓存里面没有找到对应的条目，那么 Chrome 会搜索操作系统自身的 DNS 缓存,如果找到且没有过期则停止搜索解析到此结束.<br>注：怎么查看操作系统自身的 DNS 缓存，以 Windows 系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 </p><p>3.如果在 Windows 系统的 DNS 缓存也没有找到，那么尝试读取 hosts 文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的 IP 地址，如果有则解析成功。</p><p>4.如果在 hosts 文件中也没有找到对应的条目，浏览器就会发起一个 DNS 的系统调用，就会向本地配置的首选 DNS 服务器（一般是电信运营商提供的，也可以使用像 Google 提供的 DNS 服务器）发起域名解析请求（通过的是 UDP 协议向 DNS 的 53 端口发起请求，这个请求是递归的请求，也就是运营商的 DNS 服务器必须得提供给我们该域名的 IP 地址），运营商的 DNS 服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的 DNS 代我们的浏览器发起迭代 DNS 解析请求，它首先是会找根域的 DNS 的 IP 地址（这个 DNS 服务器都内置 13 台根域的 DNS 的 I P地址），找打根域的 DNS 地址，就会向其发起请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的 IP 地址是多少啊？），根域发现这是一个顶级域 com 域的一个域名，于是就告诉运营商的 DNS 我不知道这个域名的 IP 地址，但是我知道 com 域的 IP 地址，你去找它去，于是运营商的 DNS 就得到了com 域的 IP 地址，又向 com 域的 IP 地址发起了请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的 IP 地址是多少?）,com 域这台服务器告诉运营商的 DNS 我不知道 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的 IP 地址，但是我知道 linux178.com 这个域的 DNS 地址，你去找它去，于是运营商的 DNS 又向 linux178.com 这个域名的 DNS 地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的 IP 地址是多少？），这个时候 linux178.com 域的 DNS 服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的 DNS 服务器，这个时候运营商的 DNS 服务器就拿到了 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名对应的 IP 地址，并返回给 Windows 系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 对应的 IP 地址，该进行一步的动作了。</p><p>注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤：<br>5.操作系统就会查找 NetBIOS name Cache（NetBIOS 名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和 IP 地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p><p>6.如果第5步也没有成功，那会查询 WINS 服务器（是 NETBIOS 名称和 IP 地址对应的服务器）</p><p>7.如果第6步也没有查询成功，那么客户端就要进行广播查找</p><p>8.如果第7步也没有成功，那么客户端就读取 LMHOSTS 文件（和 HOSTS 文件同一个目录下，写法也一样）</p><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><p>DNS 也是开销，通常浏览器查找一个给定域名的 IP 地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p><p>当客户端 DNS 缓存（浏览器和操作系统）缓存为空时，DNS 查找的数量与要加载的 Web 页面中唯一主机名的数量相同，包括页面 URL、脚本、样式表、图片、Flash 对象等的主机名。减少主机名的 数量就可以减少 DNS 查找的数量。</p><p>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1 规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少 DNS 查找的同时也允许高度并行下载。</p><h2 id="精简-JavaScript"><a href="#精简-JavaScript" class="headerlink" title="精简 JavaScript"></a>精简 JavaScript</h2><h3 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h3><p>精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。</p><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。</p><p>缺点：</p><p>混淆本身比较复杂，可能会引入错误。</p><p>需要对不能改变的符号做标记，防止 JavaScript 符号（譬如关键字、保留字）被修改。</p><p>混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。</p><p>在以上提到了关于用 gzip 之类的压缩方式来压缩文件，这边说明一下，就算使用 gzip 等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。</p><h2 id="CSS-的精简"><a href="#CSS-的精简" class="headerlink" title="CSS 的精简"></a>CSS 的精简</h2><p>CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。</p><p>除了移除空白、注释之外，CSS可以通过优化来获得更多的节省：</p><p>合并相同的类；</p><p>移除不使用的类；</p><p>使用缩写，譬如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.right &#123;</span><br><span class="line">    color: #fff;</span><br><span class="line"></span><br><span class="line">    padding-top: 0; </span><br><span class="line"></span><br><span class="line">    margin: 0 10px;</span><br><span class="line">    </span><br><span class="line">    border: 1px solid #111</span><br><span class="line">&#125;</span><br><span class="line">.wrong &#123;</span><br><span class="line">    color: #ffffff;</span><br><span class="line"></span><br><span class="line">    padding-top: 0px; </span><br><span class="line"></span><br><span class="line">    margin-top: 0;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    border-color: #111;</span><br><span class="line">    border-width: 1px;</span><br><span class="line">    border-style: solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><h3 id="什么是重定向？"><a href="#什么是重定向？" class="headerlink" title="什么是重定向？"></a>什么是重定向？</h3><p>重定向用于将用户从一个URL重新路由到另一个URL。</p><h3 id="常用重定向的类型"><a href="#常用重定向的类型" class="headerlink" title="常用重定向的类型"></a>常用重定向的类型</h3><p>301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。</p><p>302：临时重定向，主要实现 post 请求后告知浏览器转移到新的 URL。</p><p>304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件 GET 请求，如果服务器的组件并没有修改过，则会返回 304 状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。</p><h3 id="重定向如何损伤性能？"><a href="#重定向如何损伤性能？" class="headerlink" title="重定向如何损伤性能？"></a>重定向如何损伤性能？</h3><p>当页面发生了重定向，就会延迟整个 HTML 文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p><p>来看一个实际例子：对于 ASP.NET webform 开发来说，对于新手很容易犯一个错误，就是把页面的连接写成服务器控件后台代码里，例如用一个 Button 控件，在它的后台 click 事件中写上：Response.Redirect(“”)；然而这个 Button 的作用只是转移 URL，这是非常低效的做法，因为点击 Button 后，先发送一个 Post 请求给服务器，服务器处理Response.Redirect(“”) 后就发送一个 302 响应给浏览器，浏览器再根据响应的 URL 发送 GET 请求。正确的做法应该是在 html 页面直接使用 a 标签做链接，这样就避免了多余的 post 和重定向。</p><h3 id="重定向的应用场景"><a href="#重定向的应用场景" class="headerlink" title="重定向的应用场景"></a>重定向的应用场景</h3><h4 id="跟踪内部流量"><a href="#跟踪内部流量" class="headerlink" title="跟踪内部流量"></a>跟踪内部流量</h4><p>重定向经常用于跟踪用户流量的方向,当拥有一个门户主页的时候，同时想对用户离开主页后的流量进行跟踪，这时可以使用重定向。例如: 某网站主页新闻的链接地址<a href="http://a.com/r/news，点击该链接将产生" target="_blank" rel="noopener">http://a.com/r/news，点击该链接将产生</a> 301 响应，其 Location 被设置为 <a href="http://news.a.com。通过分析" target="_blank" rel="noopener">http://news.a.com。通过分析</a> a.com 的 web 服务器日志可以得知人们离开首页之后的去向。</p><p>我们知道重定向是如何损伤性能的，为了实现更好的效率，可以使用 Referer 日志来跟踪内部流量去向。每个 HTTP 请求都有一个 Referer 表示原始请求页(除了从书签打开或直接键入 URL 等操作)，记录下每个请求的 Referer，就避免了向用户发送重定向，从而改善了响应时间。</p><h4 id="跟踪出站流量"><a href="#跟踪出站流量" class="headerlink" title="跟踪出站流量"></a>跟踪出站流量</h4><p>有时链接可能将用户带离你的网站，在这种情况下，使用Referer就不太现实了。</p><p>同样也可以使用重定向来解决跟踪出站流量问题。以百度搜索为例，百度通过将每个链接包装到一个302重定向来解决跟踪的问题，例如搜索关键字“前端性能优化”，搜索结果中的一个 URL 为 <a href="https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生" target="_blank" rel="noopener">https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生</a> 302 重定向，将页面转到目标页面（待修改，求大神们给我指正））</p><p>除了重定向外，我们还可以选择使用信标(beacon)——一个 HTTP 请求，其 URL 中包含有跟踪信息。跟踪信息可以从信标 Web 服务器的访问日记中提取出来，信标通常是一个 1px*1px 的透明图片，不过 304 响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。</p><h2 id="删除重复脚本"><a href="#删除重复脚本" class="headerlink" title="删除重复脚本"></a>删除重复脚本</h2><p>在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多次。</p><p>重复的脚本会造成不必要的 HTTP 请求（如果没有缓存该脚本的话），并且执行多余的 JavaScript 浪费时间，还有可能造成错误。</p><p>如何避免重复脚本呢？</p><p>1.形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是必要的，所以需要对脚本进行一个良好的组织。</p><p>2.实现脚本管理器模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function insertScript($file) &#123;</span><br><span class="line">     if(hadInserted($file)) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      exeInsert($file);</span><br><span class="line">  </span><br><span class="line">      if(hasDependencies($file)) &#123;</span><br><span class="line">  </span><br><span class="line">          $deps = getDependencies($file);</span><br><span class="line"> </span><br><span class="line">         foreach ($deps as $script) &#123;</span><br><span class="line">             insertScript($script);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         echo &quot;&lt;script type=&apos;text/javascript&apos; src=&apos;&quot;.getVersion($file).&quot;&apos;&gt;&lt;/script&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先检查是否插入过，如果插入过则返回。如果该脚本依赖其它脚本，则被依赖的脚本也会被插入。最后脚本被传送到页面，getVersion 会检查脚本并返回追加了对应版本号的文件名，这样如果脚本的版本变化了，那么以前浏览器缓存的就会失效。</p><h2 id="配置-ETag"><a href="#配置-ETag" class="headerlink" title="配置 ETag"></a>配置 ETag</h2><p>以前浏览器缓存的就会失效。</p><h3 id="什么是-ETag？"><a href="#什么是-ETag？" class="headerlink" title="什么是 ETag？"></a>什么是 ETag？</h3><p>实体标签(EntityTag)是唯一标识了一个组件的一个特定版本的字符串，是 web 服务器用于确认缓存组件的有效性的一种机制，通常可以使用组件的某些属性来构造它。</p><h3 id="条件-GET-请求"><a href="#条件-GET-请求" class="headerlink" title="条件 GET 请求"></a>条件 GET 请求</h3><p>如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件 GET 请求到服务器，服务器判断缓存还有效，则发送一个 304 响应，告诉浏览器可以重用缓存组件。</p><p>那么服务器是根据什么判断缓存是否还有效呢?有两种方式：ETag（实体标签）和 最新修改日期。</p><h4 id="最新修改日期"><a href="#最新修改日期" class="headerlink" title="最新修改日期"></a>最新修改日期</h4><p>原始服务器通过 Last-Modified 响应头来返回组件的最新修改日期。</p><p>举个栗子：</p><p>当我们不带缓存访问 <a href="http://www.google.com.hk" target="_blank" rel="noopener">www.google.com.hk</a> 的时候，我们需要下载 google 的 logo，这时会发送这样一个 HTTP 请求：</p><p>Requset：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET googlelogo_color_272x92dp.png HTTP 1.1</span><br><span class="line"></span><br><span class="line">Host: www.google.com.hk</span><br></pre></td></tr></table></figure></p><p>Respone：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 200 OK</span><br><span class="line"></span><br><span class="line">Last-Modified:Fri, 04 Sep 2015 22:33:08 GMT</span><br></pre></td></tr></table></figure></p><p><img src="https://images2015.cnblogs.com/blog/861963/201603/861963-20160319143807209-1678450570.png" alt></p><p>当需要再次访问相同组件的时候，同时缓存已经过期，浏览器会发送如下条件GET请求：</p><p>Request：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET googlelogo_color_272x92dp.png HTTP 1.1</span><br><span class="line"></span><br><span class="line">If-Modified-Since:Fri, 04 Sep 2015 22:33:08 GMT</span><br><span class="line"></span><br><span class="line">Host: www.google.com.hk</span><br></pre></td></tr></table></figure></p><p>Response：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 304 Not Modified</span><br></pre></td></tr></table></figure></p><p><img src="https://images2015.cnblogs.com/blog/861963/201603/861963-20160319143556756-1561871554.png" alt></p><h4 id="实体标签"><a href="#实体标签" class="headerlink" title="实体标签"></a>实体标签</h4><p>ETag 提供了另外一种方式，用于检测浏览器缓存中的组件与原始服务器上的组件是否匹配。摘抄自书上的例子：</p><p>不带缓存的请求：</p><p>Request：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo/gif HTTP 1.1</span><br><span class="line"></span><br><span class="line">Host: us.yimg.com</span><br></pre></td></tr></table></figure></p><p>Response:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo/gif HTTP 1.1</span><br><span class="line"></span><br><span class="line">Host: us.yimg.com</span><br><span class="line"></span><br><span class="line">If-Modified-Since:Tue,12 Dec 200603:03:59 GMT</span><br><span class="line"></span><br><span class="line">If-None-Match:”10c24bc-4ab-457elc1f“</span><br></pre></td></tr></table></figure></p><p>再次请求相同组件:</p><p>Request：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo/gif HTTP 1.1</span><br><span class="line"></span><br><span class="line">Host: us.yimg.com</span><br><span class="line"></span><br><span class="line">If-Modified-Since:Tue,12 Dec 200603:03:59 GMT</span><br><span class="line"></span><br><span class="line">If-None-Match:“10c24bc-4ab-457elc1f”</span><br></pre></td></tr></table></figure></p><p>Response：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.1 304 Not Midified</span><br></pre></td></tr></table></figure></p><h3 id="为什么要引入-ETag？"><a href="#为什么要引入-ETag？" class="headerlink" title="为什么要引入 ETag？"></a>为什么要引入 ETag？</h3><p>ETag 主要是为了解决 Last-Modified 无法解决的一些问题：</p><p>1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET;</p><p>2.某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒);</p><p>3.某些服务器不能精确的得到文件的最后修改时间。</p><h3 id="ETag带来的问题"><a href="#ETag带来的问题" class="headerlink" title="ETag带来的问题"></a>ETag带来的问题</h3><p>ETag 的问题在于通常使用某些属性来构造它，有些属性对于特定的部署了网站的服务器来说是唯一的。当使用集群服务器的时候，浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件 GET 请求，ETag 就会出现不匹配的状况。例如：使用 inode-size-timestamp 来生成 ETag，文件系统使用 inode 存储文件类型、所有者、组和访问模式等信息，在多台服务器上，就算文件大小、权限、时间戳等都相同，inode 也是不同的。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>1.如果使用 Last-Modified 不会出现任何问题，可以直接移除 ETag，google 的搜索首页则没有使用 ETag。</p><p>2.确定要使用 ETag，在配置 ETag 的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用 size-timestamp 来生成时间戳。</p><h2 id="使-Ajax-可缓存"><a href="#使-Ajax-可缓存" class="headerlink" title="使 Ajax 可缓存"></a>使 Ajax 可缓存</h2><p>维基百科中这样定义Ajax：</p><p>JAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。Ajax的概念由杰西·詹姆士·贾瑞特所提出。</p><p>传统的Web应用允许用户端填写表单（form），当提交表单时就向Web服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p><p>与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p><p>类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。而客户端与服务器也并不需要异步。一些基于AJAX的“派生／合成”式（derivative/composite）的技术也正在出现，如AFLAX。</p><p>Ajax的目地是为突破web本质的开始—停止交互方式，向用户显示一个白屏后重绘整个页面不是一种好的用户体验。</p><h3 id="异步与即时"><a href="#异步与即时" class="headerlink" title="异步与即时"></a>异步与即时</h3><p>Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。</p><p>用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动请求是基于用户当前的操作而发起的</p><h3 id="什么样的-AJAX-请求可以被缓存？"><a href="#什么样的-AJAX-请求可以被缓存？" class="headerlink" title="什么样的 AJAX 请求可以被缓存？"></a>什么样的 AJAX 请求可以被缓存？</h3><p>POST 的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码 200。（可以在服务器端对数据进行缓存，以便提高处理速度）</p><p>GET 的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的 AJAX 请求，不会重复在服务器执行，而是返回 304。</p><h3 id="Ajax-请求使用缓存"><a href="#Ajax-请求使用缓存" class="headerlink" title="Ajax 请求使用缓存"></a>Ajax 请求使用缓存</h3><p>在进行 Ajax 请求的时候，可以选择尽量使用 get 方法，这样可以使用客户端的缓存，提高请求速度。</p><p>本文转载至：<a href="http://www.cnblogs.com/MarcoHan/" target="_blank" rel="noopener">http://www.cnblogs.com/MarcoHan/</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML知识点</title>
      <link href="/2018/11/16/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/11/16/HTML%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="img-的-alt-和-title-有什么区别"><a href="#img-的-alt-和-title-有什么区别" class="headerlink" title="img 的 alt 和 title 有什么区别"></a>img 的 alt 和 title 有什么区别</h3><p>alt 是图片加载失败时，显示在网页上的替代文字<br>title 是鼠标放上面时显示的文字</p><h3 id="a-标签的四个伪类是什么？如何排序？为什么？"><a href="#a-标签的四个伪类是什么？如何排序？为什么？" class="headerlink" title="a 标签的四个伪类是什么？如何排序？为什么？"></a>a 标签的四个伪类是什么？如何排序？为什么？</h3><p>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {} </p><p>原因：<br>首先伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活）<br>lvha 规则是由于 CSS 特殊性导致，CSS 特殊性有一个按顺序的规则（同一条 CSS 规则，后出现会覆盖前面的同样规则）<br>在这里，比如把 hover 放在 active 后面，那么实际你在激活（ active ）链接的时候就触发了 hover 伪类，hover 在后面覆盖了active 的颜色，所以始终无法看到 active 的颜色<br>如果把 visited 放在 hover 的后面，那么已经访问过的链接始终触发 visited 伪类，根据第一条会覆盖 hover 里面的颜色。<br>其实 link visited 这两个伪类，并不需要顺序关系。（他们两的位置可以交换）</p><h3 id="img-是行内元素，为什么可以设置宽高"><a href="#img-是行内元素，为什么可以设置宽高" class="headerlink" title="img 是行内元素，为什么可以设置宽高"></a>img 是行内元素，为什么可以设置宽高</h3><p>img 确实是行内元素，但它也是置换元素</p><p>置换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p><p>例如浏览器会根据 <img> 标签的 src 属性的值来读取图片信息并显示出来，而如果查看 (X)HTML 代码，则看不到图片的实际内容；</p><p>又例如根据 <input> 标签的type属性来决定是显示输入框，还是单选按钮等。</p><p>所以 img  input  select  textarea  button  label 等，他们被称为可置换元素（Replaced element）。</p><p>他们区别一般 inline 元素是：这些元素拥有内在尺寸，内置宽高，他们可以设置 width/height 属性。</p><p>他们的性质同设置了 display:inline-block 的元素一致。</p><h3 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h3><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><p>JS引擎则：解析和执行javascript来实现网页的动态效果。</p><p>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p><h3 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="常见的浏览器内核有哪些"></a>常见的浏览器内核有哪些</h3><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p><h3 id="HTML5的离线储存怎么使用，工作原理能不能解释一下"><a href="#HTML5的离线储存怎么使用，工作原理能不能解释一下" class="headerlink" title="HTML5的离线储存怎么使用，工作原理能不能解释一下"></a>HTML5的离线储存怎么使用，工作原理能不能解释一下</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：<br>1、页面头部像下面一样加入一个manifest的属性；<br>2、在cache.manifest文件的编写离线存储的资源；<br>    CACHE MANIFEST</p><pre><code>#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:/ /offline.html</code></pre><p>3、在离线状态时，操作window.applicationCache进行需求实现。</p><h3 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信"></a>如何实现浏览器内多个标签页之间的通信</h3><p>WebSocket、SharedWorker；<br>也可以调用localstorge、cookies等本地存储方式；</p><p>localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，<br>我们通过监听事件，控制它的值来进行页面信息通信；<br>注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</p><h3 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h3><p>Adobe Flash Socket 、<br>ActiveX HTMLFile (IE) 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR</p><h3 id="li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法"><a href="#li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法" class="headerlink" title="li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法"></a>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法</h3><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p><h3 id="为什么要初始化-CSS-样式"><a href="#为什么要初始化-CSS-样式" class="headerlink" title="为什么要初始化 CSS 样式"></a>为什么要初始化 CSS 样式</h3><ul><li><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p></li><li><p>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p></li></ul><p>最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）</p><p>淘宝的样式初始化代码：<br>body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }<br>body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }<br>h1, h2, h3, h4, h5, h6{ font-size:100%; }<br>address, cite, dfn, em, var { font-style:normal; }<br>code, kbd, pre, samp { font-family:couriernew, courier, monospace; }<br>small{ font-size:12px; }<br>ul, ol { list-style:none; }<br>a { text-decoration:none; }<br>a:hover { text-decoration:underline; }<br>sup { vertical-align:text-top; }<br>sub{ vertical-align:text-bottom; }<br>legend { color:#000; }<br>fieldset, img { border:0; }<br>button, input, select, textarea { font-size:100%; }<br>table { border-collapse:collapse; border-spacing:0; }</p><h3 id="某种效果，有两种实现方案都可以实现，方案一：标签；方案二：背景图，两个方案如何取舍？衡量的标准是什么"><a href="#某种效果，有两种实现方案都可以实现，方案一：标签；方案二：背景图，两个方案如何取舍？衡量的标准是什么" class="headerlink" title="某种效果，有两种实现方案都可以实现，方案一：标签；方案二：背景图，两个方案如何取舍？衡量的标准是什么?"></a>某种效果，有两种实现方案都可以实现，方案一：<img>标签；方案二：背景图，两个方案如何取舍？衡量的标准是什么?</h3><p>答: 如下场景使用img标签比较合适：<br>1、如果图像是等内容的一部分或图表或人(真正的人,而不是股票图人)，使用Img标签加上alt属性。<br>2、如果你想打印页面并且你想要的图像包括默认情况下使用IMG。<br>3、使用IMG(alt文本)图像有一个重要的语义时,比如一个警告图标。这将确保图像的意义可以很好的和user-agents沟通,包括屏幕阅读器。<br>4、如果你依赖于浏览器缩放图像比例并且可以呈现不错的效果时使用IMG。<br>5、如果配合 z - index 伸展背景图像来填补它的整个窗口时使用IMG。<br>6、使用img代替有背景图像可以显著提高性能的动画背景。<br>7、IMG会首先加载因为src在html文件本身中而在有背景图像源是样式表中引入的图像，加载样式表加载后,延迟加载的网页。</p><p>如下场景使用background-image属性比较合适：<br>1、如果图像不是内容的一部分时使用backgrond-image。<br>2、当图像代替文本使用时使用backgrond-image。<br>3、如果你想打印页面并且你不想要的图像包括默认情况下使用backgrond-image。<br>4、如果需要缩短下载时间通过CSS sprites 时使用backgrond-image。<br>5、如果你只需要展示图像的一部分通过CSS sprites，时使用backgrond-image。<br>6、如果你需要为不同的屏幕分辨率展示不同的图像使用 media查询时使用backgrond-image。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ajax请求</title>
      <link href="/2018/10/14/ajax%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/10/14/ajax%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>Ajax 技术的核心是 XMLHttpRequst 对象（简称 XHR）。<br>XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户点击后，可有不必刷新页面也能取得新数据。<br>使用 XHR 对象取得的新数据，然后再通过 DOM 将数据插入到页面中。<br>虽然名字中含有 XML 的成分，但 Ajax 通信与数据格式无关。这种技术就是无须刷新页面即可从服务器取得数据，但不一定是 XML 数据。</p><h2 id="jq-ajax请求"><a href="#jq-ajax请求" class="headerlink" title="jq ajax请求"></a>jq ajax请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;&apos;, // 请求地址</span><br><span class="line">    type: &apos;post&apos;, // 请求方式</span><br><span class="line">    async: false. // 同步请求还是异步请求</span><br><span class="line">    data: &apos;&apos;,  // 请求参数</span><br><span class="line">    dataType: &apos;&apos;, // 跨域 json 请求一定是 jsonp</span><br><span class="line">    beforeSend: function() &#123;</span><br><span class="line">        // 请求前的处理</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">        // 请求成功的处理</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: function() &#123;</span><br><span class="line">        // 请求完成的处理</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function(err) &#123;</span><br><span class="line">        // 请求出错的处理</span><br><span class="line">    &#125;,</span><br><span class="line">    xhrFields: &#123;</span><br><span class="line">        withCredentials: true    // 此字段标识要跨域传数据,表示前端设置是否带cookie</span><br><span class="line">    &#125;,</span><br><span class="line">    crossDomain: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ajax-中-post-和-get-的区别"><a href="#ajax-中-post-和-get-的区别" class="headerlink" title="ajax 中 post 和 get 的区别"></a>ajax 中 post 和 get 的区别</h2><p>1 GET 请求会将参数跟在 URL 后进行传递，而 POST 请求则是作为 HTTP 消息的实体内容发送给 WEB 服务器。<br>2.GET 方式提交的数据最多只能是 1024 字节，POST 传输的数据量大，可以达到 2M。<br>3.GET 方式请求数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号密码等。在某种情况下，GET 方式会带来严重的安全问题,而 POST 方式相对来说就可以避免这些问题。<br>4.POST 请求必须设置 Content-Type 值为 application/x-form-www-urlencoded。<br>5.发送请求时,因为 GET 请求的参数都在 URL 里,所以 send 函数发送的参数为 null,而 POST 请求在使用 send 方法时,需赋予其参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function postMethod()&#123;</span><br><span class="line">    // 通过使用 XMLHttpRequest 构造函数创建 XHR 对象</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    // 请求数据</span><br><span class="line">    var userName = document.getElementById(&quot;userName&quot;).value;</span><br><span class="line">    var age = document.getElementById(&quot;age&quot;).value;</span><br><span class="line">    var data = &#123;</span><br><span class="line">        userName: encodeURTComponent(&apos;userName&apos;),</span><br><span class="line">        age: encodeURTComponent(&apos;age&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不用担心缓存问题</span><br><span class="line">    xhr.open( &quot;post&quot;, &quot;example.php&quot;, true );</span><br><span class="line"></span><br><span class="line">    // 模仿表单提交时的内容类型。必须设置,否则服务器端收不到参数</span><br><span class="line">    xhr.setRequestHeader( &quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot; );</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">        if( xhr.readyState = 4 &amp;&amp; xhr.status == 200 )&#123;</span><br><span class="line">            document.getElementById(&quot;result&quot;).innerHTML = xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发送请求,要data数据</span><br><span class="line">    xhr.send( data );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getMethod() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    var userName = document.getElementById(&quot;userName&quot;).value;</span><br><span class="line">    var age = document.getElementById(&quot;age&quot;).value;</span><br><span class="line"></span><br><span class="line">    //添加参数,以求每次访问不同的 url,以避免缓存问题</span><br><span class="line">    xhr.open( &quot;get&quot;, &quot;example.php?userName=&quot; + encodeURTComponent( userName ) + &quot;&amp;age=&quot; + encodeURTComponent( age ) + &quot;&amp;random=&quot; + Math.random(), true );</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = function()&#123;</span><br><span class="line"></span><br><span class="line">        if( xhr.readyState == 4 &amp;&amp; xhr.status == 200 )&#123;</span><br><span class="line"></span><br><span class="line">            document.getElementById(&quot;result&quot;).innerHTML = xhr.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果不需要通过请求主体发送数据，则必须传入 null</span><br><span class="line">    xhr.send( null );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关属性如下<br>responseText: 作为响应主体被返回的文本<br>responseXML: 如果响应的内容类型是 “text/xml” 或 “application/xml”，这个属性中将保存包含着响应数据的 XML DOM 文档<br>status: 响应的 HTTP 状态<br>statusText: HTTP 状态的说明</p><p>一般来说，可以将 HTTP 状态代码为 200 作为成功的标志，此时可以访问 responseText。<br>状态码 304 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。</p><h2 id="封装-ajax-调用"><a href="#封装-ajax-调用" class="headerlink" title="封装 ajax 调用"></a>封装 ajax 调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 基于jquery 的 ajax 封装</span><br><span class="line">var dataSimplify = function(res) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        data: res.data,</span><br><span class="line">        state: res.state</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var localhost = &quot;http://119.29.202.92:8080/&quot;</span><br><span class="line"></span><br><span class="line">var $http = &#123;</span><br><span class="line">    post:function(url, data, _success) &#123;</span><br><span class="line">        var commonParams = &#123;</span><br><span class="line">            data: data,</span><br><span class="line">        &#125;;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            cache: false,</span><br><span class="line">            async: true,</span><br><span class="line">            url: decodeURIComponent(localhost + url),</span><br><span class="line">            contentType: &quot;application/json&quot;,</span><br><span class="line">            dataType: &quot;json&quot;,</span><br><span class="line">            data: JSON.stringify(commonParams),</span><br><span class="line">            success: function(res) &#123;</span><br><span class="line">                var _res = dataSimplify(res);</span><br><span class="line">                if (_success) &#123;</span><br><span class="line">                    _success(_res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function() &#123;</span><br><span class="line">                alert(&apos;请求失败&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            timeout: function() &#123;</span><br><span class="line">                alert(&apos;网络缓慢,请稍后重试.....&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 封装 ajax 调用 webService</span><br><span class="line"> * @param &#123;Object&#125; url     请求地址</span><br><span class="line"> * @param &#123;Object&#125; data    请求参数</span><br><span class="line"> * @param &#123;Object&#125; call    成功回调</span><br><span class="line"> * @param &#123;Object&#125; errCall 错误回调</span><br><span class="line"> * @param &#123;Object&#125; bool    同步还是异步</span><br><span class="line"> */</span><br><span class="line">jQuery.rozWebPost = function(url, data, call, errCall, bool) &#123;</span><br><span class="line">var boo = true; /*true 异步刷新 ajax、false 同步刷新 ajax*/</span><br><span class="line">if(bool) &#123;</span><br><span class="line">if(typeof bool == &quot;boolean&quot;) &#123;</span><br><span class="line">boo = bool;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(typeof data == &quot;function&quot;) &#123;</span><br><span class="line">call = data;</span><br><span class="line">data = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">errCall = errCall || function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type: &apos;POST&apos;,</span><br><span class="line">url: url,</span><br><span class="line">data: data,</span><br><span class="line">async: boo,</span><br><span class="line">dataType: &quot;json&quot;,</span><br><span class="line">cache: false,</span><br><span class="line">crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">contentType: &quot;application/x-www-form-urlencoded;charset=UTF-8&quot;,</span><br><span class="line">success: function(jsonData) &#123;</span><br><span class="line">if(typeof jsonData == &apos;string&apos;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">call($.parseJSON(jsonData));</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">call(jsonData);</span><br><span class="line">&#125;</span><br><span class="line">if(url.indexOf(&quot;add&quot;) &lt; 0 || url.indexOf(&quot;Add&quot;) &lt; 0) &#123;</span><br><span class="line">$(&quot;.Addclass&quot;).unbind(&quot;click&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">error: errCall</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用正则表达式来写表单提交</title>
      <link href="/2018/10/13/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E5%86%99%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/"/>
      <url>/2018/10/13/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E5%86%99%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<p>用正则来验证表单<br><a id="more"></a></p><h2 id="正则表达式验证表单"><a href="#正则表达式验证表单" class="headerlink" title="正则表达式验证表单"></a>正则表达式验证表单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//创建验证函数check</span><br><span class="line">function check() &#123;　　　　　</span><br><span class="line">    //获取表单中id为name的元素的value值</span><br><span class="line">    name = document.getElementById(&quot;name&quot;).value;</span><br><span class="line">    //判断获取到的value值为空的时候，输出提示“请输入姓名”，返回</span><br><span class="line">    　　　　　</span><br><span class="line">    if (name == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;请输入姓名！&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;　</span><br><span class="line">    /* </span><br><span class="line">        * 验证手机号码  /^1[34578]\d&#123;9&#125;$/</span><br><span class="line">        */</span><br><span class="line">    //正则表达式：开始数字为1，第二位数字为3/4/5/7/8，最后再加9位数字</span><br><span class="line">    re = /^1[34578]\d&#123;9&#125;$/;　　　　　</span><br><span class="line">    //获取表单中id为tel的元素的value值</span><br><span class="line">    tel = document.getElementById(&quot;tel&quot;).value;　　　　　</span><br><span class="line">    //用正则表达式匹配它，若为真接着往下执行，若为假，输出提示“请输入正确的手机号！”</span><br><span class="line">    if (re.test(tel)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;请输入正确的手机号！&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;　　　　　</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">        * 验证获取的验证码 /^bd\d&#123;6&#125;tt$/</span><br><span class="line">        */</span><br><span class="line">    //正则表达式：开始为bd,在家6位随机数，最后在加 tt</span><br><span class="line">    yze = /^bd\d&#123;6&#125;tt$/;　　　　　</span><br><span class="line">    //获取表单中id为yz的元素的value值</span><br><span class="line">    yz = document.getElementById(&quot;yz&quot;).value;　　　　　</span><br><span class="line">    //用正则表达式匹配它，若为真接着往下执行，若为假，输出提示“请向客服代表咨询索取验证码”</span><br><span class="line">    if (yze.test(yz)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;请向客服代表咨询索取正确验证码&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><p>常用到的正则表达式：<br>　　中文字符的正则表达式： [\u4e00-\u9fa5]<br>　　评注：匹配中文还真是个头疼的事，有了这个表达式就好办了</p><p>　　匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p><p>　　匹配空白行的正则表达式：\n\s*\r<br>　　评注：可以用来删除空白行</p><p>　　匹配HTML标记的正则表达式：&lt;(\S<em>?)[^&gt;]</em>&gt;.<em>?&lt;/\1&gt;|&lt;.</em>? /&gt;<br>　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p><p>　　匹配首尾空白字符的正则表达式：^\s<em>|\s</em>$<br>　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p><p>　　匹配Email地址的正则表达式：\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*<br>　　评注：表单验证时很实用</p><p>　　匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*<br>　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p><p>　　匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>　　评注：表单验证时很实用</p><p>　　匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}<br>　　评注：匹配形式如 0511-4405222 或 021-87888822</p><p>　　匹配腾讯QQ号：[1-9][0-9]{4,}<br>　　评注：腾讯QQ号从10000开始</p><p>　　匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>　　评注：中国邮政编码为6位数字</p><p>　　匹配身份证：\d{15}|\d{18}<br>　　评注：中国的身份证为15位或18位</p><p>　　匹配ip地址：\d+.\d+.\d+.\d+<br>　　评注：提取ip地址时有用</p><p>　　匹配特定数字：<br>　　^[1-9]\d<em>$　 　 //匹配正整数<br>　　^-[1-9]\d</em>$ 　 //匹配负整数<br>　　^-?[1-9]\d<em>$　　 //匹配整数<br>　　^[1-9]\d</em>|0$　 //匹配非负整数（正整数 + 0）<br>　　^-[1-9]\d<em>|0$　　 //匹配非正整数（负整数 + 0）<br>　　^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>$　　 //匹配正浮点数<br>　　^-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>)$　 //匹配负浮点数<br>　　^-?([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0)$　 //匹配浮点数<br>　　^[1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d<em>|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）<br>　　^(-([1-9]\d</em>.\d<em>|0.\d</em>[1-9]\d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0）<br>　　评注：处理大量数据时有用，具体应用时注意修正</p><p>　　匹配特定字符串：<br>　　^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串<br>　　^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串<br>　　^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串<br>　　^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串<br>　　^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目经验</title>
      <link href="/2018/10/12/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
      <url>/2018/10/12/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式运用"><a href="#正则表达式运用" class="headerlink" title="正则表达式运用"></a>正则表达式运用</h2><p>验证输入框只能输入 3-4 位数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个正则表达式（字面量形式）</span><br><span class="line">var reg = /\d&#123;3,4&#125;/;   // 验证失败</span><br><span class="line">var reg = /^\d&#123;3,4&#125;$/; // 验证成功</span><br><span class="line"> </span><br><span class="line">// 用 test() 方法进行检测</span><br><span class="line">reg.test(&apos;123&apos;);   // true</span><br><span class="line">reg.test(&apos;1234&apos;);  // true</span><br><span class="line">reg.test(&apos;12345&apos;); // true</span><br><span class="line"></span><br><span class="line">// 用 test() 方法进行检测</span><br><span class="line">reg.test(&apos;123&apos;);   // true</span><br><span class="line">reg.test(&apos;1234&apos;);  // true</span><br><span class="line">reg.test(&apos;12345&apos;); // false</span><br></pre></td></tr></table></figure></p><p>从上面的程序来看，验证通过和失败其实是对正则表达式的不理解，想当然的以为那就是我想验证的。</p><p>/\d{3,4}/ 不是匹配 3-4 位数字，而是匹配至少 3 位数字，往后验证都是 true。<br>而 /^\d{3,4}$/ 才是真正的匹配 3-4 位数字，相比上面加入匹配的开始和结束。</p><p>注意：以上的匹配必须是连续一起的位数才能通过。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript数据类型</title>
      <link href="/2018/10/10/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/10/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMAScirpt 变量有两种不同的数据类型：基本类型，引用类型。也有其他的叫法，比如原始类型和对象类型，拥有方法的类型和不能拥有方法的类型，还可以分为可变类型和不可变类型，其实这些叫法都是依据这两种的类型特点来命名。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本的数据类型有：undefined、boolean、number、string、null。<br>基本类型的访问时按值访问的，就是说你可以操作保存在变量中的实际的值。</p><h3 id="基本类型的值是不可变得"><a href="#基本类型的值是不可变得" class="headerlink" title="基本类型的值是不可变得"></a>基本类型的值是不可变得</h3><p>任何方法都无法改变一个基本类型的值，比如一个字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;john&apos;;</span><br><span class="line">name.toUpperCase(); // JOHN</span><br><span class="line">console.log(name);  // john</span><br></pre></td></tr></table></figure></p><p>调用了 toUpperCase( )方法后返回的是一个新的字符串，原始的 name 值并未发生改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &apos;john&apos;;</span><br><span class="line">person.age = 22;</span><br><span class="line">person.method = function() &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.age);    // undefined</span><br><span class="line">console.log(person.method); // undefined</span><br></pre></td></tr></table></figure><h3 id="基本类型的比较是值得比较"><a href="#基本类型的比较是值得比较" class="headerlink" title="基本类型的比较是值得比较"></a>基本类型的比较是值得比较</h3><p>基本类型的比较，只有在它们值相等的时候才相等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = true;</span><br><span class="line">console.log(a == b); // true</span><br></pre></td></tr></table></figure></p><p>上面程序返回的是 true，这个程序涉及到了类型转换和 == 运算符的知识了。<br>在用 == 进行运算时，如果比较的是两个不同类型的变量时， == 运算符会进行类型的转换，将 true 转换为数字 1，然后再跟 1 进行比较，结果就是 true 了。</p><p>当两个值的类型相同的时候，即使是 == 也相当于是 ===。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;john&apos;;</span><br><span class="line">var b = &apos;john&apos;;</span><br><span class="line">console.log(a === b); // true</span><br></pre></td></tr></table></figure></p><h3 id="基本类型的变量是存放在栈区的（栈区指内存里的栈内存）"><a href="#基本类型的变量是存放在栈区的（栈区指内存里的栈内存）" class="headerlink" title="基本类型的变量是存放在栈区的（栈区指内存里的栈内存）"></a>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</h3><p>假如有以下几个基本类型的变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;john&apos;;</span><br><span class="line">var city = &apos;guangzhou&apos;;</span><br><span class="line">var age = 22;</span><br></pre></td></tr></table></figure></p><p>那么它的存储结果如下图：<br><img src="http://wx2.sinaimg.cn/mw690/7cefed4dgy1fw3etxf2qsj20ad04ogm3.jpg" alt><br>栈区包括了变量的标示符和变量的值。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>javascript 中除了上面的基本类型之外就是引用类型了，也可以说就是对象了。<br>对象是属性和方法的集合，也就是说引用类型可以拥有属性和方法，属性又可以包含基本类型和引用类型。</p><h3 id="引用类型的值是可变的"><a href="#引用类型的值是可变的" class="headerlink" title="引用类型的值是可变的"></a>引用类型的值是可变的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">person.name = &apos;john&apos;;</span><br><span class="line">person.age = 22;</span><br><span class="line">person.sayName = function() &#123;</span><br><span class="line">    console.log(person.sayName);</span><br><span class="line">&#125;</span><br><span class="line">person.sayName(); // john</span><br><span class="line"></span><br><span class="line">delete person.name; // 删除 person 对象的 name 属性</span><br><span class="line">person.sayName();   // undefined</span><br></pre></td></tr></table></figure><p>上面程序说明引用类型可以拥有属性和方法，并且是可以动态改变的。</p><h3 id="引用类型的值是同时保存在栈内存和堆内存中的对象"><a href="#引用类型的值是同时保存在栈内存和堆内存中的对象" class="headerlink" title="引用类型的值是同时保存在栈内存和堆内存中的对象"></a>引用类型的值是同时保存在栈内存和堆内存中的对象</h3><p>javascript 和其他语言不通，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，那我们操作啥呢？<br>实际上是操作对象的引用，所以引用类型的值是按引用访问的。<br>准确的说，引用类型的存储需要内存的栈区和堆区(堆区是指内存里的堆内存)共同完成，也可以说是该对象在堆内存的地址。<br>假如有以下几个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;name:&apos;john&apos;&#125;;</span><br><span class="line">var person2 = &#123;name:&apos;xiaom&apos;&#125;;</span><br><span class="line">var person3 = &#123;name:&apos;xiaoh&apos;&#125;;</span><br></pre></td></tr></table></figure></p><p>则这三个对象在内存中保存的情况如下图：<br><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1fw3demeon8j20ho04pq2v.jpg" alt></p><h3 id="引用类型的比较是引用的比较"><a href="#引用类型的比较是引用的比较" class="headerlink" title="引用类型的比较是引用的比较"></a>引用类型的比较是引用的比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &apos;&#123;&#125;&apos;;</span><br><span class="line">var person2 = &apos;&#123;&#125;&apos;;</span><br><span class="line">console.log(person1 == person2); // true</span><br></pre></td></tr></table></figure><p>上面是两个相同类型的比较，都是字符串的比较，所以输出的是 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;&#125;;</span><br><span class="line">var person2 = &#123;&#125;;</span><br><span class="line">console.log(person1 == person2); // false</span><br></pre></td></tr></table></figure><p>当比较的是对象时，两个的值就不相等了，输出的是 false。<br>原因嘛，当然是因为引用类型是按引用访问的，所以比较的是两个对象的堆内存中的地址是否相同，很明显，person1 和 person2 在堆内存中地址是不同的，如下图所示：<br><img src="http://wx1.sinaimg.cn/mw690/7cefed4dgy1fw3deomexpj20ht03jglh.jpg" alt></p><h2 id="简单赋值"><a href="#简单赋值" class="headerlink" title="简单赋值"></a>简单赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = a;</span><br><span class="line"></span><br><span class="line">a++;</span><br><span class="line">console.log(a); // 11</span><br><span class="line">console.log(b); // 10</span><br></pre></td></tr></table></figure><p>定义了 a 变量后，用 a 变量初始化 b 时，b 中保存的值也为10，但 b 和 a 是完全独立的，两个变量参与的任何操作都互不影响。<br><img src="http://wx2.sinaimg.cn/mw690/7cefed4dgy1fw3denz2csj20i403zglg.jpg" alt></p><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><p>当你从一个变量向另一个变量赋值引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到新变量分配的空间中。前面提到引用类型保存在变量中的是对象在堆内存的地址，所以这个值得副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象。赋值操作后，两个变量都保存了同一个对象地址。因此改变其中任何一个变量，都会相互影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;; // a 保存了一个空对象实例</span><br><span class="line">var b = a;  // a 和 b 都指向了这个空对象</span><br><span class="line"></span><br><span class="line">a.name = &apos;john&apos;;</span><br><span class="line">console.log(a.name); // john</span><br><span class="line">console.log(b.name); // john</span><br><span class="line"></span><br><span class="line">b.age = 22;</span><br><span class="line">console.log(a.age);  // 22</span><br><span class="line">console.log(b.age);  // 22</span><br></pre></td></tr></table></figure></p><p>它们之间的关系如下图所示：<br><img src="http://wx2.sinaimg.cn/mw690/7cefed4dgy1fw3dennkgjj20i20870sv.jpg" alt></p><p>本文参考至：<a href="https://www.cnblogs.com/luochp3/p/5773386.html" target="_blank" rel="noopener">https://www.cnblogs.com/luochp3/p/5773386.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象的引用和合并</title>
      <link href="/2018/10/07/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%90%88%E5%B9%B6/"/>
      <url>/2018/10/07/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…<br>此外，JavaScript 允许自定义对象。<br>JavaScript 提供多个内建对象，比如 String、Date、Array 等等。<br>对象只是带有属性和方法的特殊数据类型。</p><h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>对象之间的赋值，只是将地址指向同一个，而不是真正意义上的拷贝,只是引用了相同的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 自定义对象</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = obj;    // 复制对象</span><br><span class="line">obj2.a = 20;       // 修改属性值</span><br><span class="line">console.log(obj2); // 20</span><br></pre></td></tr></table></figure></p><p>由于对象类型直接赋值，只是将引用指向同一个地址，导致修改了 obj2 会导致 obj 也被修改</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>深拷贝与浅拷贝的区别：<br>浅拷贝直接把引用地址原样拿来，此时，不管源对象还是目标对象，修改引用属性后另一个对象的同名属性都会受到影响。<br>深拷贝则会递归地在目标对象上创建值，目标对象和源对象之间将完全独立。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>通过 for in 循环获取基本类型，赋值每一个基本类型，才能真正意义上的复制一个对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function copy(obj) &#123;</span><br><span class="line">    var newObj = &#123;&#125;;</span><br><span class="line">    for (var attr in obj) &#123;</span><br><span class="line">        newObj[attr] = obj[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = copy(obj);</span><br><span class="line">obj2.a = 20;</span><br><span class="line">console.log(obj.a); // 10</span><br></pre></td></tr></table></figure></p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>浅拷贝存在一个问题，如果 obj 中的 a 不是一个数值 10，而是一个对象，这样就会导致在 for　in 中，将 a 这个对象的引用赋值为新对象，导致存在对象引用的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function copy(obj) &#123;</span><br><span class="line">    var newObj = &#123;&#125;;</span><br><span class="line">    for (var attr in obj) &#123;</span><br><span class="line">        newObj[attr] = obj[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = copy(obj);</span><br><span class="line">obj2.a.b = 20;</span><br><span class="line">console.log(obj.a.b); // 20</span><br></pre></td></tr></table></figure></p><p>因为当前 copy 这个函数只是对第一层进行拷贝，无法拷贝深层的对象，所以我们需要通过递归来拷贝深层对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">    if (typeof obj != &apos;object&apos;) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    var newObj = &#123;&#125;;</span><br><span class="line">    for (var attr in obj) &#123;</span><br><span class="line">        newObj[attr] = deepCopy(obj[attr]);</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = deepCopy(obj);</span><br><span class="line">obj2.a.b = 20;</span><br><span class="line">console.log(obj.a.b); // 10</span><br></pre></td></tr></table></figure></p><p>除此之外，还可以利用合并来作拷贝：<br>1.JSON.parse(JSON.stringify())<br>先将对象变为字符串，然后再变为 json 对象，防止对象的指针指向问题<br>2.$.extend()<br>传 true 为深拷贝，不传为浅拷贝</p><h2 id="对象的合并"><a href="#对象的合并" class="headerlink" title="对象的合并"></a>对象的合并</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>浅合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a:3,</span><br><span class="line">    c:3</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.assign(obj1,obj2)); // &#123;a: 3, b: 2, c: 3&#125;</span><br><span class="line">var obj3 = $.assign(obj1,obj2); // 做浅拷贝，和 obj1 拥有一样的对象</span><br></pre></td></tr></table></figure></p><h3 id="extend"><a href="#extend" class="headerlink" title="$.extend()"></a>$.extend()</h3><p>浅合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a:undefined,</span><br><span class="line">    c:3</span><br><span class="line">&#125;</span><br><span class="line">console.log($.extend(obj1,obj2)); // &#123;a: undefined, b: 2, c: 3&#125;</span><br><span class="line">var obj3 = $.extend(obj1,obj2); // 做浅拷贝，和 obj1 拥有一样的对象</span><br></pre></td></tr></table></figure></p><p>深合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">    a:undefined,</span><br><span class="line">    c:3</span><br><span class="line">&#125;</span><br><span class="line">console.log($.extend(true,obj1,obj2)); // &#123;a: 1, b: 2, c: 3&#125;</span><br><span class="line">var obj3 = $.extend(obj1,obj2); // 做深拷贝，和 obj1 拥有一样的对象</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScripts </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>删除数组的项</title>
      <link href="/2018/10/06/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B9/"/>
      <url>/2018/10/06/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="删除数组第一项"><a href="#删除数组第一项" class="headerlink" title="删除数组第一项"></a>删除数组第一项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5];</span><br><span class="line">var arr2 = []; // 采用中转数组</span><br><span class="line">for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i]) &#123;</span><br><span class="line">        arr2.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr2); // [2,3,4,5]</span><br></pre></td></tr></table></figure><h2 id="删除数组指定的项"><a href="#删除数组指定的项" class="headerlink" title="删除数组指定的项"></a>删除数组指定的项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var id = 1;</span><br><span class="line">var arr2 = [1, 2, 3, 4];</span><br><span class="line">arr2.splice(id - 1, 1);</span><br><span class="line">console.log(arr2); // [2, 3, 4]</span><br></pre></td></tr></table></figure><h2 id="去除数组的重复元素"><a href="#去除数组的重复元素" class="headerlink" title="去除数组的重复元素"></a>去除数组的重复元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function removeRepeating(arr) &#123;</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        for (var k = i + 1; k &lt; arr.length; k++) &#123;</span><br><span class="line">            if (arr[i] == arr[k]) &#123;</span><br><span class="line">                arr.splice(k, 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var newArr = [1, 2, 1, 3, 2, 3, 5, 6, 5];</span><br><span class="line">removeRepeating(newArr);</span><br><span class="line">console.log(newArr); // [1, 2, 3, 5, 6]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取字符串中出现次数最多的字母</title>
      <link href="/2018/09/27/%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D/"/>
      <url>/2018/09/27/%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="采用-replace-函数"><a href="#采用-replace-函数" class="headerlink" title="采用 replace 函数"></a>采用 replace 函数</h2><p>思路：<br>首先使用字符串中的 substr 方法取得字符串中第一个字母，然后通过 replace 方法全局替换掉得到一个新的字符串，然后判断原来字符串和新字符串的长度，如此循环比较。</p><p>知识点：<br>substr(指定字符串的开始位置，返回的字符个数)，基于子字符串创建新的字符串。<br>replace(RegExp 对象或一个字符串，一个字符串或一个函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function find(str) &#123;</span><br><span class="line">  var maxLength = 0, // 用来存最大数量的变量，并初始化为 0</span><br><span class="line">      maxChar;        // 用来保存结果</span><br><span class="line"></span><br><span class="line">  while(str != &quot;&quot;)&#123;</span><br><span class="line">    var oldstr = str;</span><br><span class="line">    // 获取字符串的首个字母 </span><br><span class="line">    var getstr = str.substr(0,1);</span><br><span class="line">    // 将原始字符串中这个字母出现的地方全部替换成&quot;&quot;，也就是去掉这个字母</span><br><span class="line">    str = str.replace(new RegExp(getstr,&quot;g&quot;),&quot;&quot;);</span><br><span class="line">    // 将原来的字符串和新字符串的的长度进行比较</span><br><span class="line">    if(oldstr.length - str.length &gt;maxLength)&#123;</span><br><span class="line">        maxLength = oldstr.length - str.length;</span><br><span class="line">        maxChar = getstr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    &quot;max&quot;: maxLength,</span><br><span class="line">    &quot;char&quot;: maxChar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var str = &apos;abcdefgsdds&apos;;</span><br><span class="line">console.log(find(str)); // &#123;max: 3, char: &quot;d&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="采用-split-函数"><a href="#采用-split-函数" class="headerlink" title="采用 split 函数"></a>采用 split 函数</h2><p>思路：<br>将字符串转化为数组，用数组的方法得出结果后，再转换为字符串，首先确定一个字母，然后循环跟后面的字母进行比较，相等则增加一次出现的次数，并且与最大的出现次数进行比较，保存下当前的次数和字母的索引值。</p><p>知识点：<br>split(字符串 或 RegExp 对象，指定数组大小)<br>基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function find(str) &#123;</span><br><span class="line">  var arr = str.split(&apos;&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;s&apos;, &apos;d&apos;, &apos;d&apos;, &apos;s&apos;, &apos;d&apos;, &apos;d&apos;, &apos;d&apos;];</span><br><span class="line"></span><br><span class="line">  var length = 0, // 判断出现的次数</span><br><span class="line">      maxLength = 0; // 判断出现的最大次数</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      length = 0; // 重置字母出现的次数</span><br><span class="line">      for (var k = 1; k &lt; arr.length; k++) &#123;</span><br><span class="line">          if (arr[i] == arr[k]) &#123;</span><br><span class="line">              length++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 与出现的最大次数进行比较</span><br><span class="line">      if (length &gt; maxLength) &#123;</span><br><span class="line">          maxLength = length;</span><br><span class="line">          char = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">      &quot;max&quot;: maxLength,</span><br><span class="line">      &quot;char&quot;: char</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = &apos;abcdefgsdds&apos;;</span><br><span class="line">console.log(find(str)); // &#123;max: 3, char: &quot;d&quot;&#125;</span><br></pre></td></tr></table></figure><p>思路：<br>选中字符串的第一个，将这个字母作为分隔符，即去掉该字母，然后再连接成字符串，比较前后的长度差得出结果</p><p>知识点：<br>charAt(基于 0 的字符位置)，以单字符字符串的形式返回给定位置的那个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function find(str) &#123;</span><br><span class="line">  var maxLength = 0,</span><br><span class="line">      maxChar;</span><br><span class="line">  while (str) &#123;</span><br><span class="line">      var char = str.charAt(0);</span><br><span class="line">      var a = str.split(char);</span><br><span class="line">      var count = str.length - (str = a.join(&quot;&quot;)).length;</span><br><span class="line">      if (count &gt; maxLength) &#123;</span><br><span class="line">          maxLength = count;</span><br><span class="line">          maxChar = char;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">      &quot;max&quot;: maxLength,</span><br><span class="line">      &quot;char&quot;: maxChar</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = &apos;abcdefgsdds&apos;;</span><br><span class="line">console.log(find(str)); // &#123;max: 3, char: &quot;d&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="采用-hash-计数统计"><a href="#采用-hash-计数统计" class="headerlink" title="采用 hash 计数统计"></a>采用 hash 计数统计</h2><p>思路：<br>将每一个字母循环放到一个对象中，如果对象中已经存在这个就在这基础上再加上1，如果没有则从 0 开始加1，也就是只有一个。</p><p>知识点：<br>hasOwnProperty(要检测的属性字符串名称或者符号) 判断属性是否存在<br>a++ 和 ++a 的相同点都是给 a+1，不同点是 a++ 是先参加程序的运行再 +1，而 ++a 则是先 +1 再参加程序的运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function find(str) &#123;</span><br><span class="line">  var hash = &#123;&#125;,</span><br><span class="line">      maxLength = 0,</span><br><span class="line">      maxChar;</span><br><span class="line">  var length = str.length;</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">      var char = str.charAt(i);</span><br><span class="line">      if (hash.hasOwnProperty(char)) &#123;</span><br><span class="line">          var count = hash[char]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          count = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      hash[char] = ++count; // 这里一定是用 ++count</span><br><span class="line">      if (count &gt; maxLength) &#123;</span><br><span class="line">          maxLength = count;</span><br><span class="line">          maxChar = char;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">      &quot;max&quot;: maxLength,</span><br><span class="line">      &quot;char&quot;: maxChar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = &apos;abcdefgsdds&apos;;</span><br><span class="line">console.log(find(str)); // &#123;max: 3, char: &quot;d&quot;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文档流</title>
      <link href="/2018/09/22/%E6%96%87%E6%A1%A3%E6%B5%81/"/>
      <url>/2018/09/22/%E6%96%87%E6%A1%A3%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>在 CSS 中，文档流是一个很基础也是很重要的一个概念。很多时候她被称为 Document Flow，但在 CSS 的标准被称为 Normal Flow，即普通流或常规流。大家更喜欢称之为文档流。那么CSS的文档流是怎么一回事呢？</p><p>我们常说的文档流其实分为分为定位流、浮动流和普通流三种。</p><p>在 HTML 中任何一个元素其实就是一个对象，也是一个盒子。在默认情况下它是按照出现的先后顺序来排列，而这个排列的顺序就是文档流。</p><p>文档流是元素在 Web 页面上的一种呈现方式。所有的 HTML 元素都是块盒子（Block Boxes，块级元素）或行内框（Inline Boxes，行内元素）。当浏览器开始渲染 HTML 文档时，它从窗口的顶端开始，经过整个文档内容的过程中，分配元素需要的空间。除非文档的尺寸被 CSS 规则限定，否则浏览器垂直扩展文档来容纳全部的内容。每个新的块级元素渲染为新行。行内元素则按照顺序被水平渲染直到当前行遇到边界，然后换到下一行垂直渲染。</p><p>如果你读过 CSS 相关的规范，不难发现这样的过程包括了块格式化(BFC：Block formatting context)、行内格式化（IFC：Inline formatting context）、相对定位（Relative positioning）和 Run-in Boxes 的定位。</p><p>事实上，在普通文档流中的盒子属于一种格式化上下文（Formatting Context，简称 FC）,它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。大家较为熟悉的就是块格式化上下文（Block formatting context，简称 BFC）和行内格式化上下文（Inline formatting context，简称 IFC）。不过有一点面要注意，它们只能是其中一者，但不能同时属于两者。言外之意，任何被渲染的 HTML 元素都是一个盒子（Box），这些盒子不是块盒子就是行内盒子。即使是未被任何元素包裹的文本，根据不同的情况，也会属于匿名的块盒子或行内盒子。</p><p>综合上面的描述，也可以理解格式化上下文对元素盒子做了一定的范围的限制，其实就是类似有一个 width 和 heigh 做了限制一样。如果从这方面来理解的话，普通流就是这样的一个过程：</p><p>在对应的块格式化上下文中，块级元素按照其在 HTML 源码中出现的顺序，在其容器盒子里从左上角开始，从上到下垂直地依次分配空间层叠（Stack），并且独占一行，边界紧贴父盒子边缘。两相邻元素间的距离由 margin 属性决定，在同一个块格式化上下文中的垂直边界将被重叠（Collapse margins）。除非创建一个新的块格式化上下文，否则块级元素的宽度不受浮动元素的影响。<br>在对应的行内格式化上下文中，行内元素从容器的顶端开始，一个接一个地水平排列。<br>扯了这么多，如果简单的描述就是：如何排列 HTML 元素而已。拿个块格式化上下文的普通文档流来举例，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div&gt;2&lt;/div&gt;</span><br><span class="line">&lt;div&gt;3&lt;/div&gt;</span><br><span class="line">&lt;div&gt;4&lt;/div&gt;</span><br><span class="line">&lt;div&gt;5&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>对应的效果如下：<br><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1fvi91g65o2j203304m3y9.jpg" alt></p><p>上例中看到的文档流就是一个普通的文档流，也是一个正常的普通文档流。</p><p>在 CSS 中也可以通过 float 或者 position:absolute 两种方法让元素脱离文档流。而这两者的表现实际上非常相似。简单的可以理解为部分无视和完全无视的区别：</p><p>使用 float 脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用 position:absolute 脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它(可以说是完全无视)。</p><h2 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h2><p>在介绍文档流的一节中，多次提到了格式化上下文这个概念。那么格式化上下文指的又是什么呢？</p><p>格式化上下文指的是初始元素定义的环境。</p><p>其主要包含两个要点，一个是元素定义的环境，另一个是初始化。</p><p>在 CSS 中，元素定义的环境有两种，也就是前面提到：块格式化上下文和行内格式化上下文。这两种上下文定义了在 CSS 中元素所处的环境，格式化则表明了在这个环境中，元素处理此环境中应当被初始化。用一句话来描述就是：</p><p>元素在此环境中应当如何排版布局等。</p><p>块格式化上下文其实也是大家常常称为的 BFC，指的是 Web 页面的可视化 CSS 渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS获取当前点击元素的索引值</title>
      <link href="/2018/08/21/JS%E2%80%94for%E5%BE%AA%E7%8E%AF%E6%98%BE%E7%A4%BA%E7%AC%AC%E5%87%A0%E4%B8%AA/"/>
      <url>/2018/08/21/JS%E2%80%94for%E5%BE%AA%E7%8E%AF%E6%98%BE%E7%A4%BA%E7%AC%AC%E5%87%A0%E4%B8%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>1.点击获取一堆类名相同的 div<br>2.将获取到的数组进行循环<br>3.点击显示当前的索引值</p><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>1.querySelector、querySelectorAll 的使用<br>2.for 循环作用域<br>3.addEventListener()</p><h2 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h2><p>作用域问题以及闭包的使用</p><h2 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h2><p>最基本，最符合逻辑的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 获取 div</span><br><span class="line">// 注意选择时要区别是 class 还是 id，即要加上 &apos;.box&apos; 或者 &apos;#box&apos;</span><br><span class="line">// 原生的 getElementById 就不需要，本身的意思就确定了是 class 还是 id 亦或者是标签</span><br><span class="line">// 原先的 document.getElementById(&apos;box&apos;) 则不用添加</span><br><span class="line">var aBox = document.querySelectorAll(&apos;.box&apos;); // 返回的是一个数组</span><br><span class="line"></span><br><span class="line">// 对数组进行循环操作 aBox.length </span><br><span class="line">for (var i = 0; i &lt;aBox.length; i++) &#123;</span><br><span class="line">    aBox[i].addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码执行后，不管点击哪一个，返回的都是 5</p><p>原因：在 for 循环里面指定给 aBox 的事件处理程序，也就是 addEventListener 绑定的匿名函数，是在 for 循环执行完成后（此时的 i 已经是最大值），用户点击后才被调用的，而调用时，需要对变量 i 求值，解析程序首先会在事件处理程序内部查找变量 i，没有找到则在外层查找，此时外层的 i 有定义，但 i 的值是 5（只有 i 大于 5 才会停止执行 for 循环），因此，无论点击哪一个，最后返回的值都是一样的。<br><!-- 这正是闭包（匿名函数）要使用其外部作用域中变量的结果。而且，这也是由于匿名函数本身无法传递参数（故而无法维护自己的作用域）造成的。 --></p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 自执行函数，每次循环就将变量 i 保存到自执行函数中</span><br><span class="line">for (var i = 0; i &lt; aBox.length; i++) &#123;</span><br><span class="line">    (function(i) &#123;</span><br><span class="line">        aBox[i].onclick = function() &#123;</span><br><span class="line">            alert(i); //0123</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 每次循环将 i 变量保存到对应的数组项里面</span><br><span class="line">for (var i = 0; i &lt; aBox.length; i++) &#123;</span><br><span class="line">    aBox[i].index = i;</span><br><span class="line">    aBox[i].onclick = function() &#123;</span><br><span class="line">        alert(this.index); //0123</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 做一个闭包处理</span><br><span class="line">// 闭包的核心就是内部函数可以引用外部函数的参数和变量，通过返回函数来扩大函数的作用域</span><br><span class="line">for(var i=0;i&lt;aBox.length;i++)&#123;</span><br><span class="line">    aBox[i].onclick = (function(e)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            alert(e);//0123</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="querySelector-、-querySelectorAll"><a href="#querySelector-、-querySelectorAll" class="headerlink" title="querySelector 、 querySelectorAll"></a>querySelector 、 querySelectorAll</h2><p>在使用原生 JavaScript 开发中，查找 DOM 是一件很头疼的问题，因为原生的 JavsScript 所提供的 DOM 选择方法并不多，仅仅局限于 tag, name, id等方法来查找，显然是不够的。这就出现了 Selectors API,解析和树查询操作可以在浏览器内部通过编译后的代码来完成，极大的改善了性能。</p><p>querySelector 只能选择第一个匹配的节点<br>querySelectorAll 可以选择多个节点，以 ‘,’ 分隔开，返回的是个数组(NodeList)</p><p>querySelectorAll 方法返回所有满足条件的元素，返回结果是一个 NodeList 集合。<br>但是需要注意的是返回的 NodeList 是非实时的 (no-live) 的。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// 首先选取页面中 id 为 container 的元素</span><br><span class="line">var container=document.getElementById(&apos;#container&apos;);</span><br><span class="line">console.log(container.childNodes.length); // 2</span><br><span class="line"></span><br><span class="line">// 然后通过代码为其添加一个子元素</span><br><span class="line">container.appendChild(document.createElement(&apos;div&apos;));</span><br><span class="line"></span><br><span class="line">// 这个元素不但添加到页面了，这里的变量 container 也自动更新了</span><br><span class="line">console.log(container.childNodes.length)//结果为3</span><br></pre></td></tr></table></figure></p><p>优点：<br>当选择的层级关系变多时，原始的方法去获取很麻烦。这时候用 querySelector 和 querySelecotrAll 就很好用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;#header ul.left li:first-child&apos;);</span><br><span class="line">document.querySelector(&apos;#header ul.left li&apos;);</span><br></pre></td></tr></table></figure></p><p>缺点：<br>无法查找带伪类的元素，比如 querySelector(‘:hover’)，不会得到预期的效果。</p><h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h2><p>addEventListener 可以添加多个事件处理程序，按照顺序触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;btn&quot;);  </span><br><span class="line"></span><br><span class="line">//element.addEventListener(type,listener,useCapture);</span><br><span class="line">// false 传统冒泡方式， true 捕获阶段调用事件处理程序  </span><br><span class="line">btn.addEventListener(&quot;click&quot;,method1,false);  </span><br><span class="line">btn.addEventListener(&quot;click&quot;,method2,false);  </span><br><span class="line">btn.addEventListener(&quot;click&quot;,method3,false);</span><br></pre></td></tr></table></figure></p><p>执行顺序为 method1 -&gt; method2 -&gt; method3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;btn&quot;).onclick = method1;  </span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick = method2;  </span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick = method3;</span><br></pre></td></tr></table></figure><p>如果这样写，只有 method3 被执行</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>import和export</title>
      <link href="/2018/08/18/import%E5%92%8Cexport/"/>
      <url>/2018/08/18/import%E5%92%8Cexport/</url>
      
        <content type="html"><![CDATA[<p>import 用于导入模块<br>export 用于导出模块</p><h2 id="export-default-和-export"><a href="#export-default-和-export" class="headerlink" title="export default 和 export"></a>export default 和 export</h2><p>1.export default 和 export 均可以导出常量、函数、文件、模块等<br>2.你可以在其他文件或模块中通过 import + （常量 | 函数 | 文件 | 模块）名的方式将其导入，以便能够进行使用<br>2.在一个文件或模块中， export、import 可以有多个，export default 只能有一个<br>4.通过 export 方式导出，在导入的时候要加 {}，export default 则不需要</p><p>export default 和 export 的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 使用 export default，对应的 import 不需要使用大括号</span><br><span class="line"></span><br><span class="line">// 导出模块 modules.js </span><br><span class="line">export default function test() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// 导入模块 app.js</span><br><span class="line">import test form &apos;test&apos;;</span><br><span class="line"></span><br><span class="line">// 使用 export，要使用大括号</span><br><span class="line"></span><br><span class="line">// 导出模块 modules.js</span><br><span class="line">export function test() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// 导入模块 app.js</span><br><span class="line">import &#123;test&#125; from &apos;test&apos;</span><br></pre></td></tr></table></figure></p><p>使用 import 命令的时候，用户需要知道所要加载的变量名和函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有那些属性和方法。<br>所以为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 导出模块 modules.js</span><br><span class="line">// 默认导出是一个函数</span><br><span class="line">export default function() &#123;</span><br><span class="line">    console.log(&apos;spumpkin&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导入模块 app.js</span><br><span class="line">// 可以用任意名称指向 modules.js 输出的方法，不需要知道原模块输出的函数名</span><br><span class="line">import test from &apos;./modules&apos;</span><br><span class="line">test(); // spumpkin</span><br></pre></td></tr></table></figure></p><p>即使是带函数名，也是一样，在模块外部是无效的，加载的时候，视同匿名函数加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 第一种写法</span><br><span class="line">export default function test() &#123;</span><br><span class="line">    console.log(&apos;spumpkin&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">function test() &#123;</span><br><span class="line">    console.log(&apos;spumpkin&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default test;</span><br><span class="line"></span><br><span class="line">// 导入</span><br><span class="line">import test from &apos;./modules&apos;</span><br><span class="line">test(); // spumpkin</span><br></pre></td></tr></table></figure></p><p>export default 命令用于指定模块的默认输出。<br>显然，一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令</p><p>4.本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// modules.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;add as default&#125;;</span><br><span class="line">// 等同于</span><br><span class="line">// export default add;</span><br><span class="line"></span><br><span class="line">// app.js</span><br><span class="line">import &#123;default as foo&#125; from &apos;modules&apos;;</span><br><span class="line">// 等同于</span><br><span class="line">// import foo from &apos;modules&apos;</span><br></pre></td></tr></table></figure></p><p>正是因为 export default 输出一个叫做 default 的变量，所以后面不能跟变量声明语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export var a = 1; // 正确</span><br><span class="line"></span><br><span class="line">// 将变量 a 的值赋给 default</span><br><span class="line">var a = 1;</span><br><span class="line">export default a; // 正确</span><br><span class="line"></span><br><span class="line">// 赋的不是一个变量</span><br><span class="line">export default var a = 1; // 错误</span><br></pre></td></tr></table></figure></p><p>6.因为 epxort default 的本质是将命令后面的值，赋给 default 变量以后再默认，所以直接将一个值写在 export default 之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default 42; // 正确，指定对外接口为 default</span><br><span class="line"></span><br><span class="line">export 42; // 错误，没有指定对外的接口</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS插件之路</title>
      <link href="/2018/08/13/JS%E6%8F%92%E4%BB%B6%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/08/13/JS%E6%8F%92%E4%BB%B6%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="插件的条件"><a href="#插件的条件" class="headerlink" title="插件的条件"></a>插件的条件</h2><p>一个可复用的插件需要满足以下条件：<br>1.插件自身的作用域与用户当前的作用域相互独立，也就是插件内部的私有变量不能影响使用者的环境变量<br>2.插件需具备默认设置参数<br>3.插件除了具备已实现的基本功能外，需提供部分 API，使用者可以用过该 API 修改插件功能的默认参数，从而实现用户自定义插件效果<br>4.插件支持链式调用<br>5.插件需要提供监听入口，及针对指定元素进行监听，使得该元素与插件响应达到插件效果</p><p>插件的外包装<br>用函数包装<br>所谓插件，其实就是封装一个闭包中的一种函数集。</p><p>我想实现两个数字相加的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2); // 3</span><br></pre></td></tr></table></figure></p><p>当我们要实现的功能是一些简单的逻辑，就没有必要弄一些插件什么的。JS 函数本身就可以解决绝大多数问题。<br>不过在实际工作中，一般需求比较复杂。假如要实现的不单单是相加，还有相减、相乘、相除等功能呢，该怎么办呢？<br>当然可以直接把这些功能全部写出来，然后需要就调用，需要用的地方就引入这个 JS 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 加</span><br><span class="line">function add(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 减</span><br><span class="line">function sub(num1, num2) &#123;</span><br><span class="line">    return num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 乘</span><br><span class="line">function mul(num1, num2) &#123;</span><br><span class="line">    return num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 除</span><br><span class="line">function div(num1, num2) &#123;</span><br><span class="line">    return num1 / num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求余</span><br><span class="line">function sur(num1, num2) &#123;</span><br><span class="line">    return num1 % num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个人开发的时候这么写没有问题，但当2个人以上的团队开发时，如果另外一个人并不知道你定义了 add 方法，他也定义了同样的方法，那么你们之间就会产生冲突，一般称之为变量的全局污染。</p><h3 id="用全局对象包装"><a href="#用全局对象包装" class="headerlink" title="用全局对象包装"></a>用全局对象包装</h3><p>为了解决这种全局变量污染的问题，我们可以定义一个 JS 对象来接受我们的这些工具函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var plugin = &#123;</span><br><span class="line">    add: function(num1, num2) &#123;...&#125;, // 加</span><br><span class="line">    sub: function(num1, num2) &#123;...&#125;, // 减</span><br><span class="line">    mul: function(num1, num2) &#123;...&#125;, // 乘</span><br><span class="line">    div: function(num1, num2) &#123;...&#125;, // 除</span><br><span class="line">    sur: function(num1, num2) &#123;...&#125;, // 余</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugin.add(1, 2); // 3</span><br></pre></td></tr></table></figure></p><p>为了避免有人并不知道此全局变量已经定义了，再一次定义把你的对象覆盖掉，所以可以这么干<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如果定义了相同的变量就会报错</span><br><span class="line">if (!plugin) &#123; //  条件也可以写成：typeof plguin == &apos;undefined&apos;</span><br><span class="line">    var plugin = &#123;</span><br><span class="line">        // 运行的函数逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本上，这就可以算是一个插件了。解决了全局污染问题，方法函数可以抽出来放到单独的 JS 文件里面。</p><h3 id="利用闭包包装"><a href="#利用闭包包装" class="headerlink" title="利用闭包包装"></a>利用闭包包装</h3><p>利用全局对象进行包装，虽然可以实现插件的基本功能，但是 plugin 对象时定义在全局作用的，JS 变量的调用，从全局作用域上查找的速度会比在私有作用域里面慢的多，所以最好将插件写在一个私有作用域里中。<br>实现私有作用域，最好的办法就是使用闭包。<br>可以把插件当做一个函数，插件内部的变量及函数的私有变量，为了在调用插件后依旧能够使用其功能，闭包的作用就是延长函数（插件）内部变量的生命周期，使得插件函数可以重复调用，而不影响用户自身作用域。<br>故需要将插件的所有功能写在一个立即执行函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;(function(global, undefined) &#123;</span><br><span class="line">    var plugin = &#123;</span><br><span class="line">        add: function(num1, num2) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后将插件对象暴露给全局对象</span><br><span class="line">    &apos;plugin&apos; in global &amp;&amp; global.plugin = plugin;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p><p>1.在定义插件之前添加一个分号，可以防止前面的语句缺少 ; 结尾,解决 JS 合并时可能会产生的错误问题<br>2.undefined 在老一辈的浏览器是不被支持的，直接使用会报错，JS 框架要考虑到兼容性，因此增加一个形参 undefined，就算有人把外面的 undefined 定义了，里面的 undefined 依然不受影响。<br>3.把 window 对象作为参数传入，是避免了函数执行的时候要到外部取查找</p><p>其实，我们觉得直接传window对象进去，我觉得还是不太妥当。我们并不确定我们的插件就一定用于浏览器上，也有可能使用在一些非浏览端上。所以我们还可以这么干，我们不传参数，直接取当前的全局this对象为作顶级对象用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;(function(global, undefined) &#123;</span><br><span class="line">   &apos;use strict&apos; // 使用 JS 严格模式检查，使语法更规范</span><br><span class="line">   var _global;</span><br><span class="line">   var plugin = &#123;</span><br><span class="line">       add: function() &#123;...&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 将插件对象暴露给全局对象</span><br><span class="line">   _global = (function() &#123;</span><br><span class="line">       return this || (0, eval)(&apos;this&apos;);</span><br><span class="line">   &#125;());</span><br><span class="line"></span><br><span class="line">   !(&apos;plugin&apos; in _global) &amp;&amp; (_global.plugin = plugin); </span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></p><p>如此，我们不需要传入任何参数，并且解决了插件对环境的依赖性，可以在任何宿主环境上运行了。</p><p>关于立即执行函数的写法有两种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">(function()&#123;&#125;)()</span><br><span class="line"></span><br><span class="line">// 写二</span><br><span class="line">(function()&#123;&#125;())</span><br></pre></td></tr></table></figure></p><h3 id="使用模块化的规范包装"><a href="#使用模块化的规范包装" class="headerlink" title="使用模块化的规范包装"></a>使用模块化的规范包装</h3><p>虽然上面的包装基本上已经算是可以的了，但是如果是多个人一起开发一个大型的插件，这时我们要该怎么办呢？多人合作，肯定会产生多个文件，每个人负责一个小功能，那么如何才能将所有人开发的代码集合起来呢？这是一个讨厌的问题。要实现协作开发插件，必须具备如下条件：</p><p>每功能互相之间的依赖必须要明确，则必须严格按照依赖的顺序进行合并或者加载</p><p>每个子功能分别都要是一个闭包，并且将公共的接口暴露到共享域也即是一个被主函数暴露的公共对象</p><p>关键如何实现，有很多种办法。最笨的办法就是按顺序加载 js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;part1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;part2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;part3.js&quot;&gt;&lt;/script&gt;...&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>但是不推荐这么做，这样做与我们所追求的插件的封装性相背。<br>不过现在前端界有一堆流行的模块加载器，比如 require、seajs，或者也可以像类似于 Node 的方式进行加载，不过在浏览器端，我们还得利用打包器来实现模块加载，比如 browserify。<br>为了实现插件的模块化并且让我们的插件也是一个模块，我们就得让我们的插件也实现模块化的机制。<br>我们实际上，只要判断是否存在加载器，如果存在加载器，我们就使用加载器，如果不存在加载器。我们就使用顶级域对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">    module.exports = plugin;</span><br><span class="line">&#125; else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">    define(function()&#123;return plugin;&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    _globals.plugin = plugin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整的插件"><a href="#完整的插件" class="headerlink" title="完整的插件"></a>完整的插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// plugin.js</span><br><span class="line">;(function(undefined) &#123;</span><br><span class="line">    &quot;use strict&quot;</span><br><span class="line">    var _global;</span><br><span class="line">    var plugin = &#123;</span><br><span class="line">        add: function(n1,n2)&#123; return n1 + n2; &#125;,//加</span><br><span class="line">        sub: function(n1,n2)&#123; return n1 - n2; &#125;,//减</span><br><span class="line">        mul: function(n1,n2)&#123; return n1 * n2; &#125;,//乘</span><br><span class="line">        div: function(n1,n2)&#123; return n1 / n2; &#125;,//除</span><br><span class="line">        sur: function(n1,n2)&#123; return n1 % n2; &#125; //余</span><br><span class="line">    &#125;</span><br><span class="line">    // 最后将插件对象暴露给全局对象</span><br><span class="line">    _global = (function()&#123; return this || (0, eval)(&apos;this&apos;); &#125;());</span><br><span class="line">    if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = plugin;</span><br><span class="line">    &#125; else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(function()&#123;return plugin;&#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        !(&apos;plugin&apos; in _global) &amp;&amp; (_global.plugin = plugin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>引用插件，就可以对 plugin 对象进行调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 多次使用某个对象的属性或方法，可以用 with 来获取</span><br><span class="line">with(plugin) &#123;</span><br><span class="line">    console.log(add(2,1)) // 3</span><br><span class="line">    console.log(sub(2,1)) // 1</span><br><span class="line">    console.log(mul(2,1)) // 2</span><br><span class="line">    console.log(div(2,1)) // 2</span><br><span class="line">    console.log(sur(2,1)) // 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过对象.属性或对象.方法获取</span><br><span class="line">plugin.add(2,1); //3</span><br></pre></td></tr></table></figure></p><h2 id="插件的默认参数和-API"><a href="#插件的默认参数和-API" class="headerlink" title="插件的默认参数和 API"></a>插件的默认参数和 API</h2><p>函数是可以设置默认参数这种说法，而不管我们是否传有参数，我们都应该返回一个值以告诉用户我做了怎样的处理，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(param) &#123;</span><br><span class="line">    var args = !!param ? Array.prototype.slice.call(arguments) : [];</span><br><span class="line">        return args.reduce(function(pre, cur) &#123;</span><br><span class="line">                return pre + cur </span><br><span class="line">        &#125;,0)</span><br><span class="line">&#125;</span><br><span class="line">console.log(add()); // 0（不传参，结果为0）</span><br><span class="line">console.log(add(1, 2, 3, 4)); // 15（传入了参数）</span><br></pre></td></tr></table></figure></p><p>作为一个健壮的 JS 插件，我们应该把一些基本的状态参数添加到我们需要的插件上去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// plugin.js</span><br><span class="line">;(function(undefined) &#123;</span><br><span class="line">    &quot;use strict&quot;</span><br><span class="line">    var _global;</span><br><span class="line">    function result(args,fn)&#123;</span><br><span class="line">        var argsArr = Array.prototype.slice.call(args);</span><br><span class="line">        if(argsArr.length &gt; 0)&#123;</span><br><span class="line">            return argsArr.reduce(fn);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var plugin = &#123;</span><br><span class="line">        add: function()&#123;</span><br><span class="line">            return result(arguments,function(pre,cur)&#123;</span><br><span class="line">                return pre + cur;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,//加</span><br><span class="line">        sub: function()&#123;</span><br><span class="line">            return result(arguments,function(pre,cur)&#123;</span><br><span class="line">                return pre - cur;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,//减</span><br><span class="line">        mul: function()&#123;</span><br><span class="line">            return result(arguments,function(pre,cur)&#123;</span><br><span class="line">                return pre * cur;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,//乘</span><br><span class="line">        div: function()&#123;</span><br><span class="line">            return result(arguments,function(pre,cur)&#123;</span><br><span class="line">                return pre / cur;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,//除</span><br><span class="line">        sur: function()&#123;</span><br><span class="line">            return result(arguments,function(pre,cur)&#123;</span><br><span class="line">                return pre % cur;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; //余</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最后将插件对象暴露给全局对象</span><br><span class="line">    _global = (function()&#123; return this || (0, eval)(&apos;this&apos;); &#125;());</span><br><span class="line">    if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = plugin;</span><br><span class="line">    &#125; else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(function()&#123;return plugin;&#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        !(&apos;plugin&apos; in _global) &amp;&amp; (_global.plugin = plugin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">// 输出结果为：</span><br><span class="line">with(plugin)&#123;</span><br><span class="line">    console.log(add()); // 0</span><br><span class="line">    console.log(sub()); // 0</span><br><span class="line">    console.log(mul()); // 0</span><br><span class="line">    console.log(div()); // 0</span><br><span class="line">    console.log(sur()); // 0</span><br><span class="line">    console.log(add(2,1)); // 3</span><br><span class="line">    console.log(sub(2,1)); // 1</span><br><span class="line">    console.log(mul(2,1)); // 2</span><br><span class="line">    console.log(div(2,1)); // 2</span><br><span class="line">    console.log(sur(2,1)); // 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，插件都有自己的默认参数，既然参数是默认的，那就意味着我们可以随意修改参数以达到我们的需求，插件本身的意义就在于具有复用性，我们可以 new 一个对象，修改默认参数，再使用</p><h2 id="插件的钩子"><a href="#插件的钩子" class="headerlink" title="插件的钩子"></a>插件的钩子</h2><p>我们知道，设计一下插件，参数或者其逻辑肯定不是写死的，我们得像函数一样，得让用户提供自己的参数去实现用户的需求。则我们的插件需要提供一个修改默认参数的入口。<br>如上面我们说的修改默认参数，实际上也是插件给我们提供的一个 API。让我们的插件更加的灵活。<br>通常我们用的 js 插件，实现的方式会有多种多样的。最简单的实现逻辑就是一个方法，或者一个 js 对象，又或者是一个构造函数等等。<br>我们插件所谓的API，实际就是我们插件暴露出来的所有方法及属性<br>在上面的例子中，我们的 API 就是下面的几个方法，即 add，sub，mul，div，sur。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var plugin = &#123;</span><br><span class="line">    add: function(n1,n2)&#123; return n1 + n2; &#125;,</span><br><span class="line">    sub: function(n1,n2)&#123; return n1 - n2; &#125;,</span><br><span class="line">    mul: function(n1,n2)&#123; return n1 * n2; &#125;,</span><br><span class="line">    div: function(n1,n2)&#123; return n1 / n2; &#125;,</span><br><span class="line">    sur: function(n1,n2)&#123; return n1 % n2; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在插件的 API 中，我们常常将容易被修改和变动的方法或属性统称为钩子(Hook)，方法则直接叫钩子函数。这是一种形象生动的说法，就好像我们在一条绳子上放很多挂钩，我们可以按需要在上面挂东西。<br>实际上，我们即知道插件可以像一条绳子上挂东西，也可以拿掉挂的东西。那么一个插件，实际上就是个形象上的链。不过我们上面的所有钩子都是挂在对象上的，用于实现链并不是很理想。</p><p>参考至：<a href="http://www.php.cn/js-tutorial-387538.html" target="_blank" rel="noopener">http://www.php.cn/js-tutorial-387538.html</a></p><h2 id="JS-原生封装"><a href="#JS-原生封装" class="headerlink" title="JS 原生封装"></a>JS 原生封装</h2><p>我们在封装的时候会把 JS 代码放到一个自执行函数里面，这样可以防止变量冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>然后再创建一个构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var demo = function(options) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>把这个函数暴露给外部，以便全局调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var demo = function(options) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window.demo = demo;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h3 id="方法一般写在原型里，属性写在构造函数里。"><a href="#方法一般写在原型里，属性写在构造函数里。" class="headerlink" title="方法一般写在原型里，属性写在构造函数里。"></a>方法一般写在原型里，属性写在构造函数里。</h3><h3 id="插件基本雏形"><a href="#插件基本雏形" class="headerlink" title="插件基本雏形"></a>插件基本雏形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function(window,document)&#123;</span><br><span class="line">    var MaskShare = function()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;;</span><br><span class="line">    MaskShare.prototype = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    window.MaskShare = MaskShare;</span><br><span class="line">&#125;(window,document));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>防止全局变量污染的方法</title>
      <link href="/2018/08/11/%E9%98%B2%E6%AD%A2%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B1%A1%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/11/%E9%98%B2%E6%AD%A2%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B1%A1%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>全局变量的问题在于，你的 JavaScript 应用程序和 web 页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p><p>全局变量是维系不同模块之间的纽带，模块之间只能通过全局变量来访问对方提供的功能</p><p>能使用局部变量的时候，绝不要使用全局变量</p><p>在多人协作时，如果定义过多的全局变量，有可能造成全局变量冲突，也就是全局变量污染问题,以下是两种解决方法：</p><h2 id="如何避免全局变量"><a href="#如何避免全局变量" class="headerlink" title="如何避免全局变量"></a>如何避免全局变量</h2><p>1.定义全局变量命名空间<br>只创建一个全局变量，并定义该变量为当前应用容器，把其他全局变量追加在该命名空间下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var my = &#123;&#125;;</span><br><span class="line">my.name = &#123;</span><br><span class="line">    lastname: &apos;zhang&apos;,</span><br><span class="line">    firstname: &apos;san&apos;</span><br><span class="line">&#125;;</span><br><span class="line">my.work = &#123;</span><br><span class="line">    profession: &apos; front-end&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.利用匿名函数将脚本包裹起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    var plugin = &#123;&#125;; // 创建一个空对象</span><br><span class="line">    var name = &apos;John&apos;;</span><br><span class="line">    // 给对象添加一个方法</span><br><span class="line">    plugin.method = function() &#123; </span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    plugin.firstname = &apos;zhang&apos;; // 给对象添加属性</span><br><span class="line">    window.iden = plugin; // 将 plugin 对象赋给 window，作为 window 的属性</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">iden.firstname; // zhang</span><br><span class="line">iden.method(); // John</span><br></pre></td></tr></table></figure></p><h2 id="全局-window"><a href="#全局-window" class="headerlink" title="全局 window"></a>全局 window</h2><p>在文件中直接定义的变量跟函数（不嵌套在任何域底下的）都是属于全局的，也就是都在当前页面的 window 变量底下<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name;</span><br><span class="line"></span><br><span class="line">function test2() &#123;</span><br><span class="line">    i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中的 name ，test1() ，test2() 和 i 都是属于 window 底下的全局变量，也就是可以通过以下三种办法访问：<br>1.直接访问 name ，test1()<br>2.通过全局环境使用第一种方法 window[‘name’] ，window<a href>‘test1’</a>等<br>3.通过全局环境使用第二种方法 window.name ，window.test1()等</p><p>test2 函数里面出现的 i 变量，因为不是通过 var 声明的，所以解释器会认为是 test2 的上一层定义的，向上逐级查找，一直查到 window 全局，如果发现还是未定义，那么就将其挂在 window 底下成为了全局变量。</p><p>所以你直接定义的函数通通都挂到了 window 底下，这就是一种污染了，当很多人定义各种变量跟函数，你又得同时引入进来的时候，这个冲突的概率就变大了。</p><h2 id="减少污染"><a href="#减少污染" class="headerlink" title="减少污染"></a>减少污染</h2><p>那为了避免过多这样的冲突，以及模块之间的耦合性更低，需要减少这样的污染。</p><p>此时我们会想，那不要把变量定义在全局呗，采用类似 C++ 的命名空间，Java 的包的思路就行啦。</p><p>首先就是将不同的模块划入到不同的全局“包”（这里的包的概念实际上就是一个 Javascript 对象而已）。</p><p>例如，程序员A 为全局添加一个 A 变量，然后他把自己定义的函数/变量全部挂到 A 底下，这样就跟程序员 B 所定义的隔离了。</p><p>再者我们可以使用函数域来隔离一些局部变量的冲突，比如说程序员A 写的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(function(obj) &#123;</span><br><span class="line">    // 在这里边就与外边隔离了，定义的局部变量不会与外界干扰</span><br><span class="line">    // 为了跟外界达到共享的目的，还可以为其加入参数，</span><br><span class="line">    // 例如 obj,在最后调用的时候把相关的参数传进来，例如下边的 window</span><br><span class="line">    var A = &#123;&#125;; // 定义一个 A 包</span><br><span class="line">    var tmp; // 临时变量</span><br><span class="line"></span><br><span class="line">    A.i = 1; // 定义这个包里面的 i 变量</span><br><span class="line">    A.func = function()&#123;</span><br><span class="line">        alert(&apos;1&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    obj.A = A; // 把 A 包挂到 obj 底下</span><br><span class="line"></span><br><span class="line">&#125;)(window)</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">A.i; // 1</span><br><span class="line">window.A; // &#123;i: 1, func: f&#125;</span><br><span class="line">window.i; // undefined</span><br><span class="line">window.A.i; // 1</span><br></pre></td></tr></table></figure></p><p>当离开了这个函数域之后，tmp 等局部变量被销毁（只要不要存在在闭包里边），程序员A 定义的东西通通挂到了变量 window.A 底下，从而减少了很多污染，避免了不必要的冲突。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>var的重要性</title>
      <link href="/2018/08/11/var%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
      <url>/2018/08/11/var%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="var-的本质"><a href="#var-的本质" class="headerlink" title="var 的本质"></a>var 的本质</h2><p>var 的本质就是用来声明变量的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;John&apos;; // 声明变量并进行赋值</span><br></pre></td></tr></table></figure></p><h2 id="变量的作用范围"><a href="#变量的作用范围" class="headerlink" title="变量的作用范围"></a>变量的作用范围</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var str1 = &apos;John&apos;;</span><br><span class="line">var str2 = &apos;spumpkin&apos;;</span><br><span class="line">console.log(str1, str2); // John spumpkin</span><br><span class="line"></span><br><span class="line">function name() &#123;</span><br><span class="line">    var str1 = &apos;global&apos;;</span><br><span class="line">    str2 = &apos;local&apos;;  // 赋值操作，并不是声明变量，污染了 window 对象的属性</span><br><span class="line">&#125;</span><br><span class="line">name(); // 执行函数</span><br><span class="line">console.log(str1, str2); // John local </span><br><span class="line">console.log(window.str1, window.str2); // John local</span><br></pre></td></tr></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>全局作用域：在最外层定义的变量<br>局部作用域：在函数内部定义的变量</p><p>JS 作用域的特点：<br>首先在函数内部查找变量，找不到则在外层函数查找，逐步找到最外层，即 window 对象，并操作 window 对象的属性。如果这过程中存在一个则会自动停止查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;China&apos;;</span><br><span class="line">function t1()&#123;</span><br><span class="line">    var str = &apos;Japan&apos;;</span><br><span class="line">    function t2()&#123;</span><br><span class="line">        var str = &apos;USA&apos;;</span><br><span class="line">        console.log(str);</span><br><span class="line">    &#125;</span><br><span class="line">    t2();</span><br><span class="line">&#125;</span><br><span class="line">t1(); // 最终控制台输出为 USA</span><br></pre></td></tr></table></figure></p><p>执行 t1 函数，定义了 str 变量和 t2 函数<br>执行 t2 函数，也定义了 str 变量，还打印了 str，此时函数内部查找变量，发现了 str，所以直接打印，结果就是 USA，自动停止查找。</p><p>如果去掉 t1 和 t2　函数中的定义操作，则一层层的往外找，此时就会找到最外层定义的变量，打印　China。</p><h2 id="JavaScript-没有块级作用域"><a href="#JavaScript-没有块级作用域" class="headerlink" title="JavaScript 没有块级作用域"></a>JavaScript 没有块级作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        console.log(i); // 0,1,2,3,4,5,6,7,8,9</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(i); // 10</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>for 循环出来的 i 是全局变量，所以在函数外部能够去引用变量。</p><p>使用匿名函数，立即调用，利用函数内的变量作用域，避免产生全局变量，影响整体页面环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">        for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            console.log(i); // 0,1,2,3,4,5,6,7,8,9</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">    console.log(i); // i is not defined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gulp 之路</title>
      <link href="/2018/08/01/gulp-%E4%B9%8B%E8%B7%AF/"/>
      <url>/2018/08/01/gulp-%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="gulp-是什么"><a href="#gulp-是什么" class="headerlink" title="gulp 是什么"></a>gulp 是什么</h2><p>前端构建工具，gulp 是基于 Nodejs，自动化地完成 html/image、css、sass、less、javascript、coffee 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。借鉴了 Unix 操作系统的管道 （pipe） 思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。流，Node 将几乎所有 IO 操作都抽象成了 stream 的操作，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。</p><h2 id="安装-gulp"><a href="#安装-gulp" class="headerlink" title="安装 gulp"></a>安装 gulp</h2><h3 id="全局安装-gulp"><a href="#全局安装-gulp" class="headerlink" title="全局安装 gulp"></a>全局安装 gulp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g</span><br></pre></td></tr></table></figure><p>如果不加 -g 则会安装到当前项目目录下，加上-g 就会安装到全局目录里。<br>可以通过 npm config get prefix 来查看全局目录是什么<br>也可以通过 npm config set prex “目录路径”来自行设置</p><h3 id="生成配置文件-package-json"><a href="#生成配置文件-package-json" class="headerlink" title="生成配置文件 package.json"></a>生成配置文件 package.json</h3><p>package.json 是 npm 或 nodejs 都需要用到的配置文件<br>cd 进入到项目的根目录执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></p><h3 id="在项目内安装-gulp"><a href="#在项目内安装-gulp" class="headerlink" title="在项目内安装 gulp"></a>在项目内安装 gulp</h3><p>全局安装 gulp 是为了执行 gulp 任务，本地安装 gulp 则是为了调用 gulp 插件的功能。<br>–save-dev（-D）是开发时候依赖的库(如：gulp 工具)，会添加到 package.json 文件的 dependencies 内<br>–save（-S） 是你发布之后还依赖的库(如：vue 框架)，会添加到 package.json 文件的 devDeoendencies 内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp --save-dev</span><br></pre></td></tr></table></figure></p><h3 id="创建-gulp-配置文件"><a href="#创建-gulp-配置文件" class="headerlink" title="创建 gulp 配置文件"></a>创建 gulp 配置文件</h3><p>在当前项目的根目录下手动创建 gulpfile.js，并在里面敲上自己的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引入工具模块</span><br><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line"></span><br><span class="line">// 创建任务 .task(任务名， 任务函数)</span><br><span class="line">gulp.task(&apos;greet&apos;, function() &#123;</span><br><span class="line">    console.log(&apos;Hello world!&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在终端输入 gulp 任务名，就会自动读取你的配置文件，执行你的任务。<br>运行结果：<br><img src="http://wx4.sinaimg.cn/mw690/7cefed4dgy1ftypk61m56j20fe0a1q4h.jpg" alt></p><p>这样就完成了 gulp 的第一个任务了。</p><h2 id="gulp-API"><a href="#gulp-API" class="headerlink" title="gulp API"></a>gulp API</h2><h3 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task()"></a>gulp.task()</h3><p>gulp 模块的 task 方法，用于定义具体的任务。<br>gulp(任务名,[可选，当前任务需要依赖的其他任务，是一个数组],任务函数)<br>下面是一个非常简单的任务函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;greet&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Hello world!&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>task 方法还可以指定按顺序运行的一组任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 先指定 build 任务，按次序由 CSS、 JS、 imgs 三个任务所组成。</span><br><span class="line">gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]); // gulp build 运行</span><br><span class="line"></span><br><span class="line">// 也可以指定一个空的任务，再执行 CSS、 JS、 imgs 三个任务</span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;imgs&apos;]) // gulp 运行</span><br></pre></td></tr></table></figure></p><p>注意：由于每个任务都是异步调用，所以没办法保证 JS 任务的开始运行时间，正好是 CSS 任务运行结束时间。</p><p>如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;css&apos;, [&apos;greet&apos;], function() &#123;</span><br><span class="line">    // Deal with CSS here</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码表明，css 任务依赖 greet 任务，所以 css 这个任务一定会在 greet 任务运行完成后再运行。</p><p>如果一个任务的名字为 default，就表明它是“默认任务”，在命令行直接输入 gulp 命令，就会运行该任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;default&apos;, function() &#123;</span><br><span class="line">    // Your default task</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src()"></a>gulp.src()</h3><p>gulp.src() 用来获取目标文件，进行操作。<br>首先来说一下 Grunt.js 和 Gulp.js 工作方式的一个区别：<br>Grunt 主要是以文件为媒介来运行它的工作流的，比如在 Grunt 中执行完一项任务后，会把结果写入到一个临时文件中，然后可以在这个临时文件内容的基础上执行其它任务，执行完成后又把结果写入到临时文件中，然后又以这个为基础继续执行其它任务…就这样反复下去。<br>而在 Gulp 中，使用的是 Nodejs 中的 stream(流)，首先获取到需要的 stream，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 Gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 Gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 Gulp 的速度比 Grunt 快的一个原因。<br>gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取 src 下的 main.sass 文件</span><br><span class="line">gulp.src(&apos;src/main.sass&apos;)</span><br><span class="line"></span><br><span class="line">js/app.js   指定确切的文件名</span><br><span class="line">js/*.js     某个目录所有后缀名为 JS 的文件</span><br><span class="line">js/**/*.js  某个目录及其所有子目录中的所有后缀名为 JS 的文件</span><br><span class="line">!js/app.js  除了 js/app.js 以外的所有文件</span><br><span class="line">*.+(js|css) 匹配项目根目录下，所有后缀名为 JS 或 CSS</span><br></pre></td></tr></table></figure><p>gulp 内部使用了 node-glob 模块来实现其文件匹配功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">*　匹配文件路径中的0个或者多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾</span><br><span class="line">** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</span><br><span class="line">?  匹配文件路径中的一个字符（不会匹配路径分隔符）</span><br><span class="line">[...] 匹配方括号中出现字符的任意一个，当括号内第一个字符为 ^ 或 ！ 时，表示不匹配方括号中任意的字符。</span><br><span class="line">！(pattern|pattern) 不匹配括号内容任一模式</span><br><span class="line">? (pattern|pattern) 匹配括号内任一模式 0 或 1 次</span><br><span class="line">+ (pattern|pattern) 匹配括号内任一模式至少 1 次</span><br><span class="line">* (pattern|pattern) 匹配括号内任一模式 0 或多次</span><br><span class="line">@ (pattern|pattern) 匹配括号内任意模式 1 次</span><br><span class="line"></span><br><span class="line">例子如下：</span><br><span class="line">*        能匹配到 a.js 、x.y 、 abc 、abc/ ，但是不能匹配 a/b.js</span><br><span class="line">*.*      能匹配到 a.js 、style.css 、a.b 、 x.y</span><br><span class="line">*/*/*.js 能匹配到 a/b/c.js 、x/y/z.js，不能匹配到 a/b.js 、a/b/c/d.js</span><br><span class="line">**       能匹配到 abc 、a/b.js 、a/b/c.js 、x/y/z 、x/y/z/a.b ，能用来匹配所以有的目录和文件</span><br><span class="line">**/*.js  能匹配到 foo.js 、a/foo.js 、a/b/foo.js 、a/b/c/foo.js</span><br><span class="line">a/**/z   能匹配到 a/z 、a/b/z 、a/b/c/z 、a/d/g/h/j/z</span><br><span class="line">a/**b/z  能匹配到 a/b/z 、a/ab/z 、但不能匹配 a/b/ab/z，因为只有单 ** 出现才能匹配多级目录</span><br><span class="line">?.js     能匹配到 a.js 、b.js 、 c.js</span><br><span class="line">a??      能匹配到 a.b 、 abc ，但不能匹配 ab/ ，因为它不会匹配路径分隔符</span><br><span class="line">[xyz].js 能匹配到 x.js 、y.js 、z.js ，不能匹配 xy.js 、xyz.js等，整个中括号只代表一个字符</span><br><span class="line">[^xyz].js能匹配到 a.js 、b.js 、c.js ，不能匹配 x.js 、y.js 、z.js</span><br></pre></td></tr></table></figure></p><p>有多种匹配还可以用数组来指定多个成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先匹配目录下所有的 JavaScript 文件，然后排除后缀为 .min.js 的文件</span><br><span class="line">gulp.src([&apos;js/**/*.js&apos;, &apos;!js/**/*.min.js&apos;])</span><br><span class="line"></span><br><span class="line">// 注意： 使用排除模式时，即使用 ！ ，不能在数组中的第一个元素中使用。</span><br><span class="line"></span><br><span class="line">gulp.src([&apos;!js/**/*.min,js&apos;], &apos;js/**/*.js&apos;); // 不会排除任何文件</span><br></pre></td></tr></table></figure></p><p>此外，还可以使用展开模式。<br>展开模式以花括号作为定界符，根据里面的内容，会展开多个模式，最后匹配的结果为所有展开的模式相加起来得到的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a&#123;b,c&#125;d 展开为 abd 、acd</span><br><span class="line">a&#123;b,&#125;c  展开为 abc 、ac</span><br><span class="line">a&#123;0..3&#125;d 展开为 a0d 、a1d 、a2d 、a3d</span><br><span class="line">a&#123;b,c&#123;d,e&#125;f&#125;g 展开为 abg 、acdfg 、acefg</span><br><span class="line">a&#123;b,c&#125;d&#123;e,f&#125;g 展开为 abdeg 、acdeg 、abdfg 、acdfg</span><br></pre></td></tr></table></figure></p><h3 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest()"></a>gulp.dest()</h3><p>gulp.dest() 用来传送文件，同时写入文件到指定目录。<br>gulp 的使用流程一般是这样子的：<br>首先通过 gulp.src() 方法获取到我们想要处理的文件流，然后把文件流通过 pipe() 方法导入到 gulp 的插件中，最后把经过插件处理后的流再通过 pipe()方法 导入到 gulp.dest() 中，gulp.dest() 方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line"></span><br><span class="line">gulp.src(&apos;script/jquery.js&apos;)</span><br><span class="line">    .pipe(gulp.dest(&apos;dist/foo.js&apos;)); // foo.js 会认为是一个目录名，而不是文件名</span><br><span class="line">// 最终生成文件路径为 dist/foo.js/jquery.js，而不是 dist/foo.js</span><br></pre></td></tr></table></figure></p><p>gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line"> </span><br><span class="line">gulp.src(&apos;script/**/*.js&apos;) // 通配符开始出现的那部分路径为 **/*.js</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)); // 最后生成的文件路径为 dist/**/*.js</span><br><span class="line">    </span><br><span class="line">gulp.src(&apos;script/js/jquery.js&apos;) // 没有通配符出现的情况</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)); // 最后生成的文件路径为 dist/jquery.js</span><br><span class="line"></span><br><span class="line">gulp.src(&apos;script/**/*.js&apos;) // 通配符开始出现的那部分路径为 **/*.js</span><br><span class="line">    // 假设匹配到的文件路径为 script/js/main.js</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)) // 最后生成的文件路径为 dist/js/main.js</span><br><span class="line"></span><br><span class="line">gulp.src(&apos;script/*&apos;) // 通配符开始出现的那部分路径为 *</span><br><span class="line">    // 假设匹配到的文件路径为 script/main.js</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)); // 最后生成的文件路径为 dist/main.js</span><br></pre></td></tr></table></figure></p><p>通过制定 gulp.src() 方法配置参数中的 base 属性，我们可以更灵活的来改变 gulp.dest() 生成的文件路径。<br>当我们没有在 gulp.src() 方法中配置 base 属性时，base 的默认值为通配符开始出现之前那部分路径，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;app/src/**/*.js&apos;) // 此时的 base 的值为 app/src</span><br></pre></td></tr></table></figure></p><p>所以，gulp.dest() 生成的文件路径也可以理解成，我们给 gulp.dest() 中传入的路径替换掉了 gulp.src() 中的 base 路径，最终得到了生成的文件路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;app/src/**/*.css&apos;) // 此时的 base 为 app/src</span><br><span class="line">    // 假设匹配到的文件路径为 app/src/css/main.css</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)); // 用 dist 替换掉 base 路径，最终路径为 dist/css/main.css</span><br><span class="line"></span><br><span class="line">// 修改 base 路径</span><br><span class="line">gulp.src(app/src/**/*.css, &#123;base: &apos;app&apos;&#125;) // 此时的 base 为 app</span><br><span class="line">    // 假设匹配到的文件路径为 app/src/css/main.css</span><br><span class="line">    .pipe(gulp.dest(&apos;dist&apos;)); // 此时生成的文件路径为 dist/src/css/main.css</span><br></pre></td></tr></table></figure></p><p>用 gulp.dest() 把文件流写入文件，文件流仍然可以继续使用。<br>所以可以重复的发送传递给它的数据，因此可以将文件传送到多个目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(&apos;./client/template/*.jade&apos;)</span><br><span class="line">    .pipe(jade())</span><br><span class="line">    .pipe(gulp.dest(&apos;./build/templates&apos;))</span><br><span class="line">    .pipe(minify())</span><br><span class="line">    .pipe(gulp.dest(&apos;./build/minified_templates&apos;))</span><br></pre></td></tr></table></figure></p><h3 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch()"></a>gulp.watch()</h3><p>gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。</p><p>1.gulp.watch(匹配项，执行)<br>无条件自动进行的，只要任务执行了，它就会自动开始工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;uglify&apos;, function() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;reload&apos;, function() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;, &apos;reload&apos;]);</span><br></pre></td></tr></table></figure></p><p>这是有条件的，只有 watch 任务运行了，监视才开始，gulp.watch() 会自动进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;watch&apos;, function() &#123;</span><br><span class="line">    gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;, &apos;reload&apos;])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>2.gulp.watch(匹配项，回调函数)<br>每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added, changed, deleted；path 属性为发生变化的文件的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(&apos;js/**/*js&apos;, function(event) &#123;</span><br><span class="line">    console.log(event.type); // 变化类型 added 为新增，deleted 为删除，changed 为改变</span><br><span class="line">    console.log(event.path); // 变化的文件路径</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 引入工具模块</span><br><span class="line">var gulp = require(&apos;gulp&apos;); // 引入 gulp</span><br><span class="line">    html = require(&apos;gulp-minify-html&apos;); // 引入 gulp-minify-html 用于压缩 html</span><br><span class="line">    minify = require(&apos;gulp-minify-css&apos;); // 引入 gulp-minify-css 用于压缩 CSS</span><br><span class="line">    uglify = require(&apos;gulp-uglify&apos;); // 引入 gulp-uglify 用于压缩 JS</span><br><span class="line">    jshint = require(&apos;gulp-jshint&apos;); // 引入 gulp-jshint 用于检查 JS 代码</span><br><span class="line">    sass = require(&apos;gulp-sass&apos;); // 引入 gulp-sass，用于编译.sass 文件成 .css 文件</span><br><span class="line">    rename = require(&apos;gulp-rename&apos;); // 引入 gulp-rename 用于给文件重命名</span><br><span class="line">    concat = require(&apos;gulp-concat&apos;); // 引入 gulp-concat 用来合并 JS 或 CSS 文件</span><br><span class="line">    connect = require(&apos;gulp-connect&apos;); // 引入 gulp-connect 用来开启本地服务器以及自动刷新</span><br><span class="line"></span><br><span class="line">// 创建压缩 HTML 任务</span><br><span class="line">gulp.task(&apos;html&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/*.html&apos;)</span><br><span class="line">        .pipe(html())</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;))</span><br><span class="line">        .pipe(connect.reload()) // 指定被刷新的 html 路径</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建压缩 CSS 任务</span><br><span class="line">gulp.task(&apos;css&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/**/*.css&apos;)</span><br><span class="line">        .pipe(css())</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建压缩 JS 任务</span><br><span class="line">gulp.task(&apos;script&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/js/*.js&apos;) // 1.找到文件</span><br><span class="line">        .pipe(uglify(&#123; mangle: false &#125;)) // 2.压缩文件</span><br><span class="line">        .pipe(gulp.dest(&apos;dist/js&apos;)) // 3.另存压缩后的文件路径</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建编译 sass 任务</span><br><span class="line">gulp.task(&apos;sass&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/main.sass&apos;) // 目标文件</span><br><span class="line">        .pipe(sass()) // 编译成 css 文件</span><br><span class="line">        .pipe(rename(&apos;myCss.css&apos;)) // 重命名为 myCss.css</span><br><span class="line">        .pipe(gulp.dest(&apos;style/css&apos;), console.log(&apos;OK&apos;)); // 输出到指定目录</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建本地服务器运行</span><br><span class="line">gulp.task(&apos;server&apos;, function() &#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        port:8080, // 服务器的端口号</span><br><span class="line">        root: &apos;./dist&apos;, // 服务器运行的根目录</span><br><span class="line">        livereload:true // 是否自动监听，true表明自动监听</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建自动监视任务</span><br><span class="line">gulp.task(&apos;watch&apos;, function() &#123;</span><br><span class="line">    gulp.watch(&apos;src/*.html&apos;, [&apos;html&apos;]); // 监听自动刷新，但是要保存 2 次才真正刷新了。。。</span><br><span class="line">    gulp.watch(&apos;src/**/*.sass&apos;, [&apos;sass&apos;]);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;script&apos;, &apos;auto&apos;, &apos;css&apos;])</span><br></pre></td></tr></table></figure><h2 id="实时刷新问题"><a href="#实时刷新问题" class="headerlink" title="实时刷新问题"></a>实时刷新问题</h2><p>html 的压缩有两种 gulp 插件，一种是 gulp-minify-html，另外一种是 gulp-htmlmin。<br>在对 html 的实时刷新问题上，经过测试，使用 gulp-htmlmin 比较靠谱。测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">// var html = require(&apos;gulp-minify-html&apos;); // 实时刷新要保存 2 次才刷新到，偶尔会错乱</span><br><span class="line">var html = require(&apos;gulp-htmlmin&apos;); // 保存会跳到空页面，因为执行的顺序不对</span><br><span class="line">var connect = require(&apos;gulp-connect&apos;);</span><br><span class="line"></span><br><span class="line">// 对 html 进行实时刷新，执行顺序错误</span><br><span class="line">gulp.task(&apos;html&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/*.html&apos;)</span><br><span class="line">        .pipe(html())</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;)) // 保存到新位置</span><br><span class="line">        .pipe(connect.reload()) // 进行刷新</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 对 html 进行实时刷新，应该先刷新，再保存</span><br><span class="line">gulp.task(&apos;html&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;src/*.html&apos;)</span><br><span class="line">        .pipe(html())</span><br><span class="line">        .pipe(connect.reload()) // 进行刷新</span><br><span class="line">        .pipe(gulp.dest(&apos;dist&apos;)) // 保存到新位置</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 实时监听</span><br><span class="line">gulp.watch(&apos;scr/*.html&apos;, [html]);</span><br></pre></td></tr></table></figure></p><p>经过对执行顺序的调整后，gulp-htmlmin 可以正常实时刷新，但是 gulp-minify-html 还是存在相同问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端构建工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BFC(块级格式化上下文)</title>
      <link href="/2018/07/29/BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2018/07/29/BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC-是什么"><a href="#BFC-是什么" class="headerlink" title="BFC 是什么"></a>BFC 是什么</h2><p>BFC(Block formatting context) 直译为“块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。</p><p>BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是 BFC。</p><h2 id="如何创建-BFC"><a href="#如何创建-BFC" class="headerlink" title="如何创建 BFC"></a>如何创建 BFC</h2><p>1.根元素或包含根元素的元素，即 HTML 元素，只要我们写了元素就已经生成了一个 BFC<br>2.浮动元素（元素的 float 不是 none）<br>3.绝对定位元素（元素的 position 为 absolute 或 fixed）<br>4.行内块元素（元素的 display 为 inline-block）<br>5.表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）<br>6.表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）<br>7.匿名表格单元格元素（元素的 display为 table、table-row、 8.table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）<br>8.overflow 值不为 visible 的块元素<br>9.display 值为 flow-root 的元素<br>10.contain 值为 layout、content或 strict 的元素<br>11.弹性元素（display为 flex 或 inline-flex元素的直接子元素）<br>12.网格元素（display为 grid 或 inline-grid 元素的直接子元素）<br>13.多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）<br>14.column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。<br>创建了块格式化上下文的元素中的所有内容都会被包含到该 BFC 中。</p><h2 id="BFC-渲染规则"><a href="#BFC-渲染规则" class="headerlink" title="BFC 渲染规则"></a>BFC 渲染规则</h2><p>1.内部的Box会在垂直方向，一个接一个地放置。</p><p>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p><p>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p><p>4.BFC的区域不会与float box重叠。</p><p>5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p><p>6.计算BFC的高度时，浮动元素也参与计算</p><h2 id="BFC-的作用"><a href="#BFC-的作用" class="headerlink" title="BFC 的作用"></a>BFC 的作用</h2><p>1.自适应两栏布局</p><p>2.可以阻止元素被浮动元素覆盖</p><p>3.可以包含浮动元素——清除内部浮动</p><p>4.分属于不同的BFC时可以阻止margin重叠</p><h2 id="渲染规则一：内部的-box-会在垂直方向，一个接着一个的放置"><a href="#渲染规则一：内部的-box-会在垂直方向，一个接着一个的放置" class="headerlink" title="渲染规则一：内部的 box 会在垂直方向，一个接着一个的放置"></a>渲染规则一：内部的 box 会在垂直方向，一个接着一个的放置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .div1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        border-bottom: 1px solid #aaa;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">        text-align: center;</span><br><span class="line">        margin: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;4&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;5&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1fvi91g65o2j203304m3y9.jpg" alt></p><h2 id="渲染规则二：同一个-BFC-的两个相邻的-box-的-margin-会发生重叠"><a href="#渲染规则二：同一个-BFC-的两个相邻的-box-的-margin-会发生重叠" class="headerlink" title="渲染规则二：同一个 BFC 的两个相邻的 box 的 margin 会发生重叠"></a>渲染规则二：同一个 BFC 的两个相邻的 box 的 margin 会发生重叠</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .div1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        border-bottom: 1px solid #aaa;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">        text-align: center;</span><br><span class="line">        margin: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;4&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;5&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/Images/BFC.gif" alt></p><h3 id="BFC-的作用：分属于不同的-BFC-时，可以阻止-margin-的重叠"><a href="#BFC-的作用：分属于不同的-BFC-时，可以阻止-margin-的重叠" class="headerlink" title="BFC 的作用：分属于不同的 BFC 时，可以阻止 margin 的重叠"></a>BFC 的作用：分属于不同的 BFC 时，可以阻止 margin 的重叠</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .div2 &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div2&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;4&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;div1&quot;&gt;5&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>给其中一个 div 外面再套一个 div，并创建了一个新的 BFC，处于不同的 BF 时，就可以阻止 margin 的重叠。<br>运行结果：<br><img src="http://wx2.sinaimg.cn/mw690/7cefed4dgy1fvilxiunf2j21400n6wef.jpg" alt></p><h2 id="渲染规则三：每个元素的-margin-box-的左边，与包含块-border-box-的左边相接触，即使存在浮动也是如此"><a href="#渲染规则三：每个元素的-margin-box-的左边，与包含块-border-box-的左边相接触，即使存在浮动也是如此" class="headerlink" title="渲染规则三：每个元素的 margin box 的左边，与包含块 border box 的左边相接触，即使存在浮动也是如此"></a>渲染规则三：每个元素的 margin box 的左边，与包含块 border box 的左边相接触，即使存在浮动也是如此</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .parent &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">        margin: 100px; /*为了证实浮动也是一样的情况*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .first-child,</span><br><span class="line">    .second-child &#123;</span><br><span class="line">        width: 30px;</span><br><span class="line">        height: 20px;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .first-child &#123;</span><br><span class="line">        float: left; /*新的 BFC*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .second-child &#123;</span><br><span class="line">        float: left; /*新的 BFC*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;!-- 给这两个子 div 加浮动，浮动的结果，如果没有清除浮动的话，父 div 不会将下面两个 div 包裹，但还是在父 div 的范围之内。 --&gt;</span><br><span class="line">    &lt;div class=&quot;first-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;second-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://wx4.sinaimg.cn/mw690/7cefed4dgy1fvio9psbh3j21400n6tbb.jpg" alt></p><h3 id="BFC-的作用：可以包含浮动元素——清除浮动"><a href="#BFC-的作用：可以包含浮动元素——清除浮动" class="headerlink" title="BFC 的作用：可以包含浮动元素——清除浮动"></a>BFC 的作用：可以包含浮动元素——清除浮动</h3><p>原理：两个子div 都位于同一个浮动的 BFC 区域中<br>给 parent 加上 overflow:hidden 样式，在父div 创建了一个 BFC，使得下面的子div 都处在父div 的同一个 BFC 区域中，就可以清除浮动。</p><p>运行结果：<br><img src="http://wx4.sinaimg.cn/mw690/7cefed4dgy1fvioxauk4vj21400a9dgs.jpg" alt></p><h2 id="渲染规则四：BFC-的区域不会与-float-box-重叠"><a href="#渲染规则四：BFC-的区域不会与-float-box-重叠" class="headerlink" title="渲染规则四：BFC 的区域不会与 float box 重叠"></a>渲染规则四：BFC 的区域不会与 float box 重叠</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .aside &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        float: left;</span><br><span class="line">        background: #f66;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background: #fcc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .text &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot; style=&quot;overflow: hidden;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot; style=&quot;float: left;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1fvisa4cyqwj21400n63yv.jpg" alt><br>从上图结果可以看出，如果是用 BFC 的话，BFC 的区域不会与 float box 进行重叠，达到想要的效果。而如果给 text 也加上浮动，两个元素还是处于相同的 BFC 下，也能达到不与 float box 进行重叠，但是达不到想要的效果。</p><h3 id="BFC-的作用：自适应两栏布局"><a href="#BFC-的作用：自适应两栏布局" class="headerlink" title="BFC 的作用：自适应两栏布局"></a>BFC 的作用：自适应两栏布局</h3><p>利用上述的BFC 的区域不会与 float box 重叠规则可以做出自适应的两栏布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body,</span><br><span class="line">    html &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .aside &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">        background: #f66;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        background: #fcc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .text &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot; style=&quot;overflow: hidden;&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="http://wx1.sinaimg.cn/mw690/7cefed4dgy1fvisrv0ck3j21400n6jrb.jpg" alt></p><h3 id="渲染规则五：BFC-就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。"><a href="#渲染规则五：BFC-就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。" class="headerlink" title="渲染规则五：BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。"></a>渲染规则五：BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 100px; height: 100px; background: #000;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;height: 200px; background: #AAA;&quot;&gt;</span><br><span class="line">    &lt;div style=&quot; width: 120px; height: 30px; background: red;&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;p&gt;content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;content&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://wx4.sinaimg.cn/mw690/7cefed4dgy1fvjdbngv61j21400n6mxi.jpg" alt><br>从上图结果可以看出，在第一个块级浮动后，红色的 div 被覆盖了，而文本没有被覆盖。</p><h3 id="float-的定义和用法"><a href="#float-的定义和用法" class="headerlink" title="float 的定义和用法"></a>float 的定义和用法</h3><p>float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。</p><p><img src="http://wx1.sinaimg.cn/mw690/7cefed4dgy1fvjd4uaivtj21400n6t96.jpg" alt><br>从上图结果可以很明确的看出，在没有 float 前，文本跟 div 是依次排列的，float 后，div 会被 float 覆盖，而文本却没有，那是因为 float 当初设计的时候就是为了使文本围绕在浮动对象的周围。</p><p>本文参考至：<a href="https://blog.csdn.net/sinat_17775997/article/details/79172319?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/sinat_17775997/article/details/79172319?utm_source=copy</a> </p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>display: inline-block 出现间隙问题</title>
      <link href="/2018/07/29/display-inline-block-%E5%87%BA%E7%8E%B0%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/29/display-inline-block-%E5%87%BA%E7%8E%B0%E9%97%B4%E9%9A%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>布局的一种方法是使用 display:inline-block 它相比于与浮动、定位最大的不同就是其没有父元素的匿名包裹特性，这使得 display:inline-block 属性的使用非常自由，可与文字，图片混排，可内嵌 bloc k属性元素，可以置身于 inline 水平的元素中。但是在使用display:inline-block 列表布局经常会遇到“换行符/空格间隙问题(4px)”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .div1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        border-bottom: 1px solid #aaa;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;div&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1fvnfbaz61dj208c03ymwy.jpg" alt><br>从上面的结果可以看到，inline-block 元素间的间隙是因为有空格或者换行，才产生了间隙。</p><h2 id="1-fons-size-0"><a href="#1-fons-size-0" class="headerlink" title="1.fons-size:0"></a>1.fons-size:0</h2><p>空格符本质上就是个字符，与 a、b、c 这些字符是同一个属性的东西，只是他是空格，透明的看不见而已（但是可以选中）。所以，只要让文字的宽度为 0，就可以解决 inline-block 产元素间换行符间隙的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 给父级设置字体大小为 0</span><br><span class="line">font-size: 0;</span><br><span class="line">// 给子级重新设置字体大小，因为父级字体为 0，继承了也为 0</span><br><span class="line">child-nth&#123;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在旧版 chrome 浏览器下没有效果，新版 chrome 有效果，具体哪一版有待进一步测试。</p><h2 id="2-letter-spacing"><a href="#2-letter-spacing" class="headerlink" title="2.letter-spacing"></a>2.letter-spacing</h2><p>letter-spacing 控制的是字间距，每一个中文文字作为一个“字”，而每一个英文字母也作为一个“字”。<br>letter-spacing 属性可以控制文字以及字母间的水平距离的，支持负值，可以让文字水平方向上重叠。<br>基本上所有的浏览器对于不同字体下的空格符的水平占据的解析都是一致，唯一有瑕疵的是在 Opera 浏览器下，两个 inline-block 元素间空白间隙使用 letter-spacing 去除的极限是 1 像素，当看上去要正好为 0 的时候，letter-spacing 似乎失效，空白间距恢复成 letter-spacing:0 时的效果。</p><h2 id="3-word-spacing"><a href="#3-word-spacing" class="headerlink" title="3.word-spacing"></a>3.word-spacing</h2><p>word-spacing 定义词间距，以空格为基准进行调节，如果多个单词被连在一起，则被 word-spacing 视为一个单词；如果汉字被空格分隔，则分隔的多个汉字就被视为不同的单词，word-spacing 属性此时有效。</p><h2 id="最终兼容方法"><a href="#最终兼容方法" class="headerlink" title="最终兼容方法"></a>最终兼容方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .div &#123;</span><br><span class="line">        font-size: 0;</span><br><span class="line">        letter-spacing: -4px;</span><br><span class="line">        word-spacing: -4px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .div1 &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 30px;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        border-bottom: 1px solid #aaa;</span><br><span class="line">        background-color: aquamarine;</span><br><span class="line">        text-align: center;</span><br><span class="line">        display: inline-block;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;div&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><button id="btn">运行结果</button><script>    window.onload = function() {        var btn = document.querySelector('#btn');        btn.onclick = function() {            var html = '';            // html += '<!DOCTYPE html>'+            //         '<html lang="en">'+            //         '<head>'+            //         '<meta charset="UTF-8">'+            //         '<title>Document</title>'            html += $('.highlight.xml .code').text();            // html += '</html>'            console.log(html);            var codeWin = window.open();            codeWin.document.write(html);        }    }</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>两栏自适应布局</title>
      <link href="/2018/07/29/%E4%B8%A4%E6%A0%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
      <url>/2018/07/29/%E4%B8%A4%E6%A0%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>两栏自适应布局，左侧固定宽度，右侧宽度自适应。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .sitebar,</span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 300px;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .sitebar &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background: green;</span><br><span class="line">        /* position: absolute; */</span><br><span class="line">    &#125;</span><br><span class="line">    .main &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .main .content &#123;</span><br><span class="line">        margin-left: 200px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;sitebar&quot;&gt;</span><br><span class="line">    侧栏</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        内容</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="http://wx2.sinaimg.cn/mw690/7cefed4dgy1ftqkuicpjoj21400n640y.jpg" alt></p><p>从上图可以看出，因为右侧红色方块设置了宽度 100%，所以无法和侧栏并排放在一起。<br>这时只要给侧栏添加一个 postition: absolute 属性就可以使得侧栏脱离文档流，这样即使给红色方块设置了百分百宽度也可以并排放一起。<br>所谓脱离文档流，即将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当没看到它，两者位置重叠都是可以的。<br>另外：<br>绝对定位的元素，在 top，right，bottom，left 属性未设置时，会紧随在其前面的兄弟元素之后，但在位置上不影响常规流中的任何元素。</p><p>运行结果：<br><img src="http://wx4.sinaimg.cn/mw690/7cefed4dgy1ftqkuj2hc5j21400n676q.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识积累</title>
      <link href="/2018/07/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
      <url>/2018/07/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="link-和-import-的区别是"><a href="#link-和-import-的区别是" class="headerlink" title="link 和 @import 的区别是"></a>link 和 @import 的区别是</h3><p>1.link 属于 HTML 标签，而 @import 是 CSS 提供的<br>2.页面被加载时，link 会同时也加载，而 @import 引用的 CSS 会等到页面被加载完在加载<br>3.import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题<br>4.link 方式的样式权重高于 @import</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局</title>
      <link href="/2018/07/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>/2018/07/25/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="自适应与响应式"><a href="#自适应与响应式" class="headerlink" title="自适应与响应式"></a>自适应与响应式</h2><p>随着不同设备的出现，要适应的分辨率越来越多，<font style="color:red">自适应</font>是最早的解决方法，“一次设计，普遍适用”，让同一个页面自适应不同大小的设备。<br>后来人们发现采用自适应的话，如果设备太小，就算网页能够根据屏幕大小进行适配，但是太小屏幕显示内容过多会看不清楚，为了解决这个问题而衍生出来<font style="color:red">响应式布局</font>。</p><h3 id="自适应和响应式的共同点："><a href="#自适应和响应式的共同点：" class="headerlink" title="自适应和响应式的共同点："></a>自适应和响应式的共同点：</h3><p>自适应和响应式两种布局方式都是为了解决在不同大小和分辨率的设备上正确显示网页的问题。</p><h3 id="自适应和响应式的不同点："><a href="#自适应和响应式的不同点：" class="headerlink" title="自适应和响应式的不同点："></a>自适应和响应式的不同点：</h3><p>首先先通过网站两个不同的网站直观的感受两者的区别<br>自适应：<a href="http://m.ctrip.com/html5/" target="_blank" rel="noopener">http://m.ctrip.com/html5/</a><br>响应式：<a href="http://segmentfault.com/" target="_blank" rel="noopener">http://segmentfault.com/</a></p><p>自适应：采用的是宽度自适应布局，最大特点就是网页内容和布局完全一样，即不管设备分辨率，尺寸如何变化，打开同一个页面看到的内容和布局基本上是一样的，不同的只是内容的尺寸。</p><p>响应式：可以自动识别屏幕尺寸并做出相应调整的网页设计，页面布局和展示的内容可能会随着屏幕尺寸变化而有所变化。</p><h2 id="实现响应式的技巧"><a href="#实现响应式的技巧" class="headerlink" title="实现响应式的技巧"></a>实现响应式的技巧</h2><h3 id="1、添加-viewport-标签，来兼容移动设备的效果展示"><a href="#1、添加-viewport-标签，来兼容移动设备的效果展示" class="headerlink" title="1、添加 viewport 标签，来兼容移动设备的效果展示"></a>1、添加 viewport 标签，来兼容移动设备的效果展示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mata name=&apos;viewport&apos; content=&apos;width=device-width, initial-scale=1.0&apos;&gt;</span><br></pre></td></tr></table></figure><p>width = device-width 宽度等于当前设备的宽度<br>initial-scale 初始的缩放比例（默认设置为 1.0）<br>user-scalable 用户是否可以手动缩放（默认为 no）</p><h3 id="2、相对大小的字体"><a href="#2、相对大小的字体" class="headerlink" title="2、相对大小的字体"></a>2、相对大小的字体</h3><p>字体不要使用 px 写死，最好使用相对大小的 em，或者高清方案 rem</p><h3 id="3、流动布局"><a href="#3、流动布局" class="headerlink" title="3、流动布局"></a>3、流动布局</h3><p>区块设置为浮动定位（float），float 的好处就是当元素放不下时会自动换到下一行</p><h3 id="4、选择性加载-css-文件"><a href="#4、选择性加载-css-文件" class="headerlink" title="4、选择性加载 css　文件"></a>4、选择性加载 css　文件</h3><p>例如屏幕最大到 767px 或者指定区间 480px-767px 时加载文件<br>网页文件加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CSS2 写法</span><br><span class="line">&lt;link rel=&apos;stylesheet&apos; media=&apos;screen and (min-width: 480px) and (max-device-width: 767px)&apos; href=&apos;style.css&apos;&gt;</span><br><span class="line"></span><br><span class="line">// 检测移动设备是不是纵向放置</span><br><span class="line">&lt;link rel=&apos;stylesheet&apos; media=&apos;screen and (orientation:portrait)&apos; href=&apos;style.css&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>CSS 文件加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(&apos;xxx.css&apos;) screen [and(min-width: 480px)] and (max-device-width: 767px);</span><br></pre></td></tr></table></figure></p><h3 id="5、媒体查询"><a href="#5、媒体查询" class="headerlink" title="5、媒体查询"></a>5、媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// CSS3 写法</span><br><span class="line">// 1200 分辨率以上</span><br><span class="line">@media screen and (min-width: 1200px) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1100 分辨率</span><br><span class="line">@media screen and (min-width: 960px) and (max-width: 1199px) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 880 分辨率</span><br><span class="line">@media screen and (min-width: 768px) and (max-width: 959px) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 720 分辨率</span><br><span class="line">@media only screen and (min-width: 480px) and (max-width: 767px)&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 440 分辨率以下</span><br><span class="line">@media only screen and (max-width: 479px) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 直接去掉 screen 也可以</span><br><span class="line">// screen 是告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体</span><br><span class="line">@media (min-width: 480px) and (max-width: 767px) &#123;</span><br><span class="line">    对应样式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测竖屏</span><br><span class="line">@media screen and (orientation: portrait) and (max-width: 720px) &#123; </span><br><span class="line">    对应样式 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测横屏</span><br><span class="line"></span><br><span class="line">@media screen and (orientation: landscape) &#123;</span><br><span class="line">    对应样式 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、图片自适应"><a href="#6、图片自适应" class="headerlink" title="6、图片自适应"></a>6、图片自适应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img &#123;</span><br><span class="line">    max-width: 100%;</span><br><span class="line">    height: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、重定义盒子宽度，让宽度包含-border-和-padding"><a href="#7、重定义盒子宽度，让宽度包含-border-和-padding" class="headerlink" title="7、重定义盒子宽度，让宽度包含 border 和 padding"></a>7、重定义盒子宽度，让宽度包含 border 和 padding</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*,*:before,*:after &#123;</span><br><span class="line">    -moz-box-sizing: border-box;</span><br><span class="line">    -webkit-box-sizing: border-box;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据现在分辨率得出以下常用的分辨率宽度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 1280px) &#123;</span><br><span class="line">  body&#123;font-size: 22px;&#125;</span><br><span class="line">&#125; </span><br><span class="line">@media (min-width: 1366px) &#123;</span><br><span class="line">  body&#123;font-size: 24px;&#125;</span><br><span class="line">&#125;  </span><br><span class="line">@media (min-width: 1440px) &#123;</span><br><span class="line">  body&#123;font-size: 25px !important;&#125;</span><br><span class="line">&#125; </span><br><span class="line">@media (min-width: 1680px) &#123;</span><br><span class="line">  body&#123;font-size: 28px;&#125;</span><br><span class="line">&#125; </span><br><span class="line">@media (min-width: 1920px) &#123;</span><br><span class="line">  body&#123;font-size: 33px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码在适用过程中顺序不能进行换位，因为如果是 1440 ，由于 1440 &gt; 1280 ，那么 1280 就会失效。<br>用 min-width时，小的放上面大的在下面，同理如果是用 max-width 那么就是大的在上面，小的在下面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>给数组添加一个项并返回数组</title>
      <link href="/2018/07/24/%E7%BB%99%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%A1%B9%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84/"/>
      <url>/2018/07/24/%E7%BB%99%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%A1%B9%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>对于数组方法来说，数组在执行操作时，无论是对数组进行添加还是进行删除，添加的都是返回数组的长度，删除的都是返回该删除的项，那么如果我要给数组添加一个项并返回一个数组该怎么操作呢，实际上跟 push() 出来的数组的方法一样的，只是我们用习惯了 push()，其他的方法就变得陌生了。关于数组的方法详细的可以参考<a href="https://spumpkin.github.io/2017/08/23/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/">数组的方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 初始化数据，仿接口返回</span><br><span class="line">var jsonData = &#123;</span><br><span class="line">    data: [&#123;</span><br><span class="line">        &apos;cityId&apos;: &apos;0&apos;,</span><br><span class="line">        &apos;cityName&apos;: &apos;广州&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">var data1 = &#123;</span><br><span class="line">    &apos;cityId&apos;: &apos;1&apos;,</span><br><span class="line">    &apos;cityName&apos;: &apos;北京&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var body = jsonData.data; // 获取 jsonData 里面的 data 数据</span><br><span class="line">console.log(body);</span><br><span class="line">body.push(data1);</span><br><span class="line">console.log(body);</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://wx3.sinaimg.cn/mw690/7cefed4dgy1ftpckeklffj208n04s74a.jpg" alt></p><p>从控制台的输出结果来看，第一个输出本身应该只有一条数据，但是现在有两条，那是因为我们进行了 push() 操作，使得原数组被改变，所以就变成两条数据了。第二个输出的内容跟第一个是相同的，前面有个 (2) 是因为经过数组方法操作，前面带有返回数组的长度。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zoom解决分辨率适应问题</title>
      <link href="/2018/07/22/zoom%E8%A7%A3%E5%86%B3%E5%88%86%E8%BE%A8%E7%8E%87%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/22/zoom%E8%A7%A3%E5%86%B3%E5%88%86%E8%BE%A8%E7%8E%87%E9%80%82%E5%BA%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>前言：web 端网站架构完，后期要适应 web 的其他分辨率，重新对项目进行样式改动，改动东西太多，不太现实。</p><p>方法：使用 CSS3 的 zoom 属性</p><p>说明：设置或检索对象的缩放比例</p><p>原理：zoom 属性相当于把网站快照成了一张图， 然后进行整体放大缩小。</p><p>缺陷：zoom 因为是从大往小变，所以相当于图片变小，像素被压缩了，出现像素模糊，花边与马赛克</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 屏幕调试分辨率为 1920 x 1080 </span><br><span class="line">// 在宽度上进行自适应，先计算出比例</span><br><span class="line">var zoom = screen.width / 1920;</span><br><span class="line"></span><br><span class="line">// 设置网页 zoom 的大小</span><br><span class="line">document.body.style.zoom = zoom;</span><br><span class="line">// transformOrigin 控制 x 轴 Y轴，因为 zoom 的缩放时相对于左上角的</span><br><span class="line">document.body.style.transformOrigin = &apos;center top&apos;;</span><br></pre></td></tr></table></figure></p><p>提示：<br>此方法只能是作为应急处理方法，不推荐从一开始就认定这个方法来解决分辨率的问题，想要自适应的话，还是要从根本上解决问题，也就是从一开始的样式和布局入手。</p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue—axios 跨域问题</title>
      <link href="/2018/03/04/Vue%E2%80%94axios%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2018/03/04/Vue%E2%80%94axios%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Axios 中文说明地址：<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a></p><ol><li>在项目中安装 axios (Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 个人使用的是 </span><br><span class="line">// cnpm install axios 下载速度比较快</span><br><span class="line">npm install axios --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>在 vue 项目中引入 axios<br>第一种<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 当前页面如果引入 axios，使用如下</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">axios.get(&apos;https://api.github.com/users/Spumpkin&apos;)</span><br><span class="line">.then(function(res)&#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;.bind(this)).catch(function(err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>第二种（项目常用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 入口文件 main.js</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">Vue.prototype.$http = axios // 把 axios 对象挂到 Vue 原型上</span><br><span class="line">// 其他页面在使用 axios 的时候直接 this.$http 就可以了</span><br><span class="line">// this 指的是当前 Vue 的实例对象，里面有个 $http 方法</span><br></pre></td></tr></table></figure></p><ol start="3"><li>在项目中使用 axios</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var _this = this;</span><br><span class="line">this.$http.get(&apos;https://api.github.com/users/Spumpkin&apos;).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>简化请求路径</li></ol><p>如果要简写请求路径，可以在 webpack 中进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 如果你用的是 webpack-simple 脚手架</span><br><span class="line">// 在 webpack.config.js 中 devServer 里面加入以下代码</span><br><span class="line">proxy: &#123;</span><br><span class="line">    &apos;/api&apos;: &#123; // api 表示当前项目请求的 key</span><br><span class="line">    target: &apos;https://api.github.com/&apos;, // 代理服务器路径</span><br><span class="line">    pathRewrite: &#123;&apos;^/api&apos; : &apos;&apos;&#125;, // 重写路径</span><br><span class="line">    changeOrigin: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果你用的是 webpack-simple 脚手架</span><br><span class="line">// 在 config/index.js 中 dev 里面加入以下代码</span><br><span class="line">proxyTable: &#123;</span><br><span class="line">    &apos;/api&apos;: &#123;</span><br><span class="line">    target: &apos;https://api.github.com/&apos;, // 设置你调用的接口域名和端口号 别忘了加http</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125;, </span><br><span class="line">    // 这里理解成用 &apos;/api&apos; 代替 target 里面的地址，后面组件中我们掉接口时直接用 api 代替</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在项目中使用</span><br><span class="line">var _this = this;</span><br><span class="line">this.$http.get(&apos;api/users/Spumpkin&apos;).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="5"><li>响应速度</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 请求时间大概 500ms</span><br><span class="line">var _this = this;</span><br><span class="line">this.$http.get(&apos;https://api.github.com/users/Spumpkin&apos;).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 请求时间大概 1.5s</span><br><span class="line">var _this = this;</span><br><span class="line">this.$http.get(&apos;api/users/Spumpkin&apos;).then(function (res) &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左右布局</title>
      <link href="/2018/01/05/%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80/"/>
      <url>/2018/01/05/%E5%B7%A6%E5%8F%B3%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h2><p>左边定宽，右边自适应</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>左边设置浮动，右边设置宽度 100%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#sidebar &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">#main &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;sidebar&quot;&gt; left &lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;main&quot;&gt; right &lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>父容器设置 display：flex；right部分设置 flex：1</p><p>知识点：<br>display：flex; 设置为弹性盒子，其子元素可以通过设置 flex 的数值来控制所占空间的比例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">#sidebar &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">#main &#123;</span><br><span class="line">    flex: 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">        left</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;main&quot;&gt;</span><br><span class="line">        right</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>知识点：<br>calc() 动态计算长度</p><p>语法：<br>calc(四则运算)</p><p>说明：<br>运算符前后需要保留一个空格，例如：width: calc(100% - 10px);<br>任何长度值都可以使用 calc() 函数进行计算;<br>calc() 函数支持 “+”, “-“, “*”, “/“，即加减乘除运算;<br>calc() 函数使用标准的数学运算优先级规则</p><p>知识点：<br>vw：viewport width。1vw = viewport 宽度的 1%，100vw = viewport width。<br>vh：viewport height。1vh = viewport 高度的 1%，100vh = viewport height。<br>浏览器支持情况：主流浏览器、IE10+</p><p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    height:100%;</span><br><span class="line">&#125;</span><br><span class="line">#header&#123;</span><br><span class="line">    height:100px;</span><br><span class="line">&#125;</span><br><span class="line">#sidebar&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width:260px;</span><br><span class="line">    min-height:calc(100% - 100px); </span><br><span class="line">&#125;</span><br><span class="line">#main&#123;</span><br><span class="line">    min-height:calc(100vh - 100px); </span><br><span class="line">    width:calc(100vw - 260px);</span><br><span class="line">    float:left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;header&quot;&gt;header&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">    left</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;main&quot;&gt;</span><br><span class="line">    right</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>伪对象选择符 :before 和 :after</title>
      <link href="/2018/01/04/%E4%BC%AA%E5%AF%B9%E8%B1%A1%E9%80%89%E6%8B%A9%E7%AC%A6-before-%E5%92%8C-after/"/>
      <url>/2018/01/04/%E4%BC%AA%E5%AF%B9%E8%B1%A1%E9%80%89%E6%8B%A9%E7%AC%A6-before-%E5%92%8C-after/</url>
      
        <content type="html"><![CDATA[<h2 id="before-before-after-after"><a href="#before-before-after-after" class="headerlink" title=":before/ ::before / :after / ::after"></a>:before/ ::before / :after / ::after</h2><p>说明：<br>设置在对象前后发生的内容。用来和 content 属性一起使用，并且必须定义 content 属性。<br>CSS3 将伪对象选择符前面的单个冒号(:)修改未双冒号(::)用来区别伪类选择符。<br>以前的写法仍有效，因为本质上并不支持伪元素的双冒号写法，而是忽略了其中一个冒号，仍以单冒号来解析，所以等同变相支持了 ::before / ::after。</p><h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><p>normal：默认值。表现与 none 值相同<br>none：不生成任何值<br>attr()：插入标签属性值<br>url()：使用指定的绝对或相对地址插入一个外部资源（图像，音频，视频或浏览器支持的其他任何资源），会按原始尺寸插入<br>string()：插入指定的文本内容<br>counter(name)：使用已命名的计数器<br>counters(name, list-style-type)：使用已命名的计数器并遵从指定的 list-style-type 属性<br>counters(name, string)：使用所有已命名的计数器<br>counters(name, string, list-style-type)：使用所有已命名的计数器并遵从指定的 list-style-type 属性<br>no-close-quote：并不插入 quotes 属性的后标记。但增加其嵌套级别<br>no-open-quote：并不插入 quotes 属性的前标记。但减少其嵌套级别<br>close-quote：插入 quotes 属性的后标记<br>open-quote：插入 quotes 属性的前标记</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">ol &#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.string p:after &#123;</span><br><span class="line">    content: &apos;after&apos;;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.attr p:after &#123;</span><br><span class="line">    content: attr(title);</span><br><span class="line">    color: #bbb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.url p:before &#123;</span><br><span class="line">    content: url(../icon.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter1 li &#123;</span><br><span class="line">    counter-increment: testname1;</span><br><span class="line">    margin-left: -40px;</span><br><span class="line">&#125;</span><br><span class="line">.counter1 li:before &#123;</span><br><span class="line">    content: counter(testname1)&quot;. &quot;;</span><br><span class="line">    color: #f00;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter2 li &#123;</span><br><span class="line">    counter-increment: testname2;</span><br><span class="line">    margin-left: -40px;</span><br><span class="line">&#125;</span><br><span class="line">.counter2 li:before &#123;</span><br><span class="line">    content: counter(testname2, lower-roman);</span><br><span class="line">    color: #f00;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.counter3 li&#123;</span><br><span class="line">    padding:2px 0;</span><br><span class="line">    counter-increment:testname3;</span><br><span class="line">&#125;</span><br><span class="line">.counter3 li:before&#123;</span><br><span class="line">    content:counter(testname3,decimal)&quot;.&quot;;</span><br><span class="line">    color:#f00;</span><br><span class="line">&#125;</span><br><span class="line">.counter3 li li&#123;</span><br><span class="line">    counter-increment:testname4;</span><br><span class="line">&#125;</span><br><span class="line">.counter3 li li:before&#123;</span><br><span class="line">    content:counter(testname3,decimal)&quot;.&quot;counter(testname4,decimal)&quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line">.counter3 li li li&#123;</span><br><span class="line">    counter-increment:testname5;</span><br><span class="line">&#125;</span><br><span class="line">.counter3 li li li:before&#123;</span><br><span class="line">    content:counter(testname3,decimal)&quot;.&quot;counter(testname4,decimal)&quot;.&quot;counter(testname5,decimal)&quot;.&quot;;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line">&lt;ul class=&quot;test&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;string&quot;&gt;</span><br><span class="line">        &lt;p&gt;红色字母在后面&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;attr&quot;&gt;</span><br><span class="line">        &lt;p title=&quot;这是一行写在属性的文字&quot;&gt;&lt;/p&gt; </span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;url&quot;&gt;</span><br><span class="line">        &lt;P&gt;我前面有张图片&lt;/P&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;counter1&quot;&gt;</span><br><span class="line">        &lt;ol&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">        &lt;/ol&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;counter2&quot;&gt;</span><br><span class="line">        &lt;ol&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">        &lt;/ol&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line"></span><br><span class="line">    &lt;li class=&quot;counter3&quot;&gt;</span><br><span class="line">        &lt;ol&gt;</span><br><span class="line">            &lt;li&gt;列表项</span><br><span class="line">                &lt;ol&gt;</span><br><span class="line">                    &lt;li&gt;列表项</span><br><span class="line">                        &lt;ol&gt;</span><br><span class="line">                            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">                            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">                        &lt;/ol&gt;</span><br><span class="line">                    &lt;/li&gt;</span><br><span class="line">                &lt;/ol&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">            &lt;li&gt;列表项&lt;/li&gt;</span><br><span class="line">        &lt;/ol&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h2 id="实际开发应用"><a href="#实际开发应用" class="headerlink" title="实际开发应用"></a>实际开发应用</h2><p>加载中 gif 图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">    list-style:none;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li i&#123;</span><br><span class="line">    width:20px;</span><br><span class="line">    height:20px;</span><br><span class="line">    border-radius:20px;</span><br><span class="line">    position:absolute;</span><br><span class="line">    border:2px solid #6feb95;</span><br><span class="line">    z-index:0;</span><br><span class="line">    left:50%;</span><br><span class="line">    top:50%;</span><br><span class="line">    margin-top:-11px;</span><br><span class="line">    margin-left:-11px;</span><br><span class="line">    animation:move 1s infinite;</span><br><span class="line">    -webkit-animation:move 1s infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li i:before&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    width:5px;</span><br><span class="line">    height:5px;</span><br><span class="line">    border-radius:4px;</span><br><span class="line">    content:&apos;&apos;;</span><br><span class="line">    box-shadow:0 0 10px #666;</span><br><span class="line">    -webkit-box-shadow:0 0 10px #666;</span><br><span class="line">    background:#fff;</span><br><span class="line">    border:1px solid #fff;</span><br><span class="line">    top:-3px;</span><br><span class="line">    left:50%;</span><br><span class="line">    margin-left:-3px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes move&#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        transform:rotateZ(0);</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform:rotateZ(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes move&#123;</span><br><span class="line">    0%&#123;</span><br><span class="line">        -webkit-transform:rotateZ(0);</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        -webkit-transform:rotateZ(360deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>input 与 textarea 的区别，并用 div 模拟 textarea</title>
      <link href="/2018/01/04/input%E4%B8%8Etextarea%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E7%94%A8div%E6%A8%A1%E6%8B%9Ftextarea/"/>
      <url>/2018/01/04/input%E4%B8%8Etextarea%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B9%B6%E7%94%A8div%E6%A8%A1%E6%8B%9Ftextarea/</url>
      
        <content type="html"><![CDATA[<h2 id="input-和-textarea-的区别"><a href="#input-和-textarea-的区别" class="headerlink" title="input 和 textarea 的区别"></a>input 和 textarea 的区别</h2><p>input: 用于为基于 Web 的表单创建交互式空间，以便接收来自用户的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; name=&quot;range&quot; value=&quot;2&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;10&quot;&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image/*&quot;&gt;</span><br><span class="line">&lt;input type=&quot;month&quot; name=&quot;month&quot; value=&quot;2017-11&quot;&gt;</span><br></pre></td></tr></table></figure><p>textarea: 代表一个多行的纯文本编辑控件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=&quot;textarea&quot; rows=&quot;10&quot; cols=&quot;50&quot;&gt;</span><br><span class="line">    Write something here</span><br><span class="line">&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p>区别：</p><ol><li>textarea 标签是成对的，内容写在标签对中间；input 是单个标签，标签的内容是通过 value 属性设置。</li><li>textarea 的值是纯文本；input 的值根据类型不同而不同。</li><li>textarea 没有 type 属性；input 有多种 type 来满足表单与用户的数据交互。</li><li>textarea 的值可以是多行的，并且有 rows 和 cols 来控制多行结构；input 的值是单行的。</li></ol><h2 id="用-div-模拟-textarea-标签"><a href="#用-div-模拟-textarea-标签" class="headerlink" title="用 div 模拟 textarea 标签"></a>用 div 模拟 textarea 标签</h2><p>步骤：</p><ol><li>给 div 添加一个 HTML 全局属性：contenteditable = ‘true’，使 div 元素变成用户可编辑的</li><li>给 div 添加样式 resize= both，使 div 可以被用户调整尺寸</li><li>增加一个属性： placeholder = ‘I am placeholder’</li><li>通过 CSS 选择器获取并显示 placeholder 的值</li></ol><p>知识点：</p><ol><li><p>resize 设置或检索对象的区域是否允许用户缩放，调节元素尺寸大小<br> 语法：<br> resize: none | both | horizontal | vertival</p><p> 取值：<br> none: 不允许用户调整元素大小<br> both: 用户可以调节元素的宽度和高度<br> horizontal: 用户可以调节元素的宽度<br> vertical: 用户可以调节元素的高度</p><p> 说明：<br> 如果希望此属性生效，需要设置对象的 overflow 属性了，值可以是 auto， hidden 或 scroll</p></li><li><p>伪对象选择符 :before 和 :after<br>传送门： <a style="color: red; border-bottom: none;" href="http://spumpkin.github.io/2018/01/04/伪对象选择符-before-和-after/">伪对象选择符 :before 和 :after</a></p></li></ol><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.textarea &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    padding: 4px;</span><br><span class="line">    border: 1px solid #888;</span><br><span class="line">    resize: both;</span><br><span class="line">    overflow: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.textarea:empty:before &#123;</span><br><span class="line">    content: attr(placeholder);</span><br><span class="line">    color: #bbb;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;textarea&quot; contenteditable=&quot;true&quot; placeholder=&quot;This is placeholder&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5的Data属性</title>
      <link href="/2018/01/04/HTML5%E7%9A%84Data%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/01/04/HTML5%E7%9A%84Data%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>我们往往会根据需要在 HTML 标记上添加自定义的属性来存储和操作数据，我们自定义的属性名字也千奇百怪，五花八门。我们可以通过原生的 getAttribute() 或 jQuery 中的 .attr() 来获取我们自定义的属性。但是前端技术在向着规范化前进。HTML5 标准规定，自定义的属性都已 data—* 开头，这样就区分开了固有属性和自定义属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;div1&quot; data-id=&quot;20&quot; data-first-name=&quot;zhang&quot; data-lastName=&quot;san&quot;&gt;测试在元素上存储一个 key-value&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var oDiv = document.querySelector(&apos;#div1&apos;);</span><br><span class="line"></span><br><span class="line">console.log(oDiv.dataset.id);        // 20</span><br><span class="line">console.log(oDiv.dataset.firstName); // zhang</span><br><span class="line">console.log(oDiv.dataset.lastname);  // san</span><br><span class="line"></span><br><span class="line">// 改变属性值</span><br><span class="line">oDiv.dataset.id = &apos;21&apos;;</span><br><span class="line">console.log(oDiv.dataset.id); // 21</span><br><span class="line"></span><br><span class="line">// 删除值</span><br><span class="line">delete oDiv.dataset.id // 删除单个属性</span><br><span class="line">delete dataset.id // dataset is not defined 删除了整个 dataset</span><br></pre></td></tr></table></figure><p>注意：<br>1.如果 data- 后面包含了 “-“，例如 date-first-name，”-“ 会去掉，并转换成为骆驼峰式的命名 firstName。这是因为 JSON Object 的 key 不能包含 “-“。</p><p>2.如果 data- 后面的单词有大写，例如 myName，将会转存成小写 myname。这里就不理解为什么会转换成小写了，JSON Object 的 key 是区分大小写的。</p><p>3.如果你想删除一个 data-* 属性，请使用 delete element.dataset.cname 或者 dataset.cname=null;</p><p>兼容性：<br>Internet Explorer 11+    Chrome 8+    Firefox 6.0+   Opera 11.10+    Safari 6+</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数表达式</title>
      <link href="/2018/01/03/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/01/03/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function functionName(arg0, arg1, arg2) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问 function 关键字后面的标识符</span><br><span class="line">// 只在 FF、 Safari、 Chrome 和 Opera 有效</span><br><span class="line">alert(functionName.name); // &apos;functionName&apos;</span><br></pre></td></tr></table></figure><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><p>执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    alert(&apos;Hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 经过函数声明提升，相当于</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    alert(&apos;Hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数表达式：能够创建函数再赋值给变量，也能够把函数作为其他函数的值返回。<br>函数表达式有几种不同的语法形式，下面是最常见的一种形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var functionName = function(arg0, arg1, arg2) &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 function 关键字后面有标识符，称为命名函数表达式</span><br><span class="line">var functionName = function fun() &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来像是变量赋值语句，创建一个函数并将它赋值给变量 functionName。<br>这种情况下创建的函数叫做匿名函数，因为 function 关键字后面没有标识符。</p><p>函数表达式与其他表达式一样，在使用前必须先赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi(); // 错误：函数还不存在</span><br><span class="line">var sayHi = function() &#123;</span><br><span class="line">    alert(&apos;Hi&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式也可以直接在函数后面加括号调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sayHi = function() &#123;</span><br><span class="line">    alert(&apos;Hi&apos;);</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><p>理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    function sayHi() &#123;</span><br><span class="line">        alert(&apos;Hi&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    function sayHi() &#123;</span><br><span class="line">        alert(&apos;Yo&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi(); // 大多数弹出 Yo，少数弹出 Hi</span><br><span class="line">``` </span><br><span class="line">表面上当 condition 为 true 时，使用第一个 sayHi() 定义，否则，使用另一个定义。实际上在 ECMAScript 中属于无效语法，JavaScript 引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略 condition。</span><br><span class="line"></span><br><span class="line">如果使用的是函数表达式则不会出现上面的情况，是正确的。</span><br></pre></td></tr></table></figure><p>var sayHi;</p><p>if (condition) {<br>    sayHi = function() {<br>        alert(‘Hi’);<br>    }<br>} else {<br>    sayHi = function() {<br>        alert(‘Yo’);<br>    }<br>}<br>sayHi();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 匿名函数</span><br><span class="line">匿名函数属于函数表达式，匿名函数有很多作用，如：</span><br><span class="line">赋予一个变量则创建函数，赋予一个事件则成为事件处理程序，创建闭包等等。</span><br><span class="line">(function &#123; // code&#125;) 是表达式</span><br><span class="line">function &#123; // code&#125; 是函数声明</span><br></pre></td></tr></table></figure></p><p>// 单独的匿名函数会报错，无法运行，也无法调用<br>function () {<br>    return ‘spumpkin’<br>}</p><p>// 通过表达式自我执行<br>(function() {<br>    console.log(‘spumpkin’)<br>})()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 立即执行函数</span><br><span class="line">立即执行函数两种写法：</span><br><span class="line">1.(function()&#123;&#125;)()</span><br><span class="line">2.(function()&#123;&#125;())</span><br><span class="line">立即执行函数可以看出很像函数表达式的调用，只是多了一对括号包裹。</span><br></pre></td></tr></table></figure></p><p>// 函数表达式的立即调用<br>var sayHi = function() {<br>    alert(‘Hi’);<br>}()</p><p>// 立即执行函数<br>(function() {<br>    alert(‘Hi’);<br>})()</p><p>// 立即执行函数<br>(function() {<br>    alert(‘Hi’);<br>}())</p><p>// 如果去掉函数外面的括号，就会报错<br>function () {<br>    console.log(‘1’)<br>} // 报错，函数需要函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然匿名函数属于函数表达式，但未进行赋值，所以 js 解析时遇到 function 关键字，默认当做一个函数声明。</span><br></pre></td></tr></table></figure></p><p>(function(a){<br>    console.log(a);   // console 输出123，使用（）运算符<br>})(123);</p><p>(function(a){<br>    console.log(a);   // console 输出1234，使用（）运算符<br>}(1234));</p><p>!function(a){<br>    console.log(a);   // console 输出12345，使用！运算符<br>}(12345);</p><p>+function(a){<br>    console.log(a);   // console 输出123456，使用+运算符<br>}(123456);</p><p>-function(a){<br>    console.log(a);   // console 输出1234567，使用-运算符<br>}(1234567);</p><p>var fn=function(a){<br>    console.log(a);   // console 输出12345678，使用=运算符<br>}(12345678)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、= 等运算符，都将函数声明转换成函数表达式，消除了javascript 引擎识别函数表达式和函数声明的歧义，告诉 javascript 引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</span><br><span class="line"></span><br><span class="line">加括号是最安全的做法，因为 ！、 +、 - 等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</span><br><span class="line"></span><br><span class="line">这样的写法是因为 javascrip t中没有私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 javascript 函数作用域链的特性，可以使用这种技术来模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以 (function()&#123;…&#125; )() 内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</span><br><span class="line"></span><br><span class="line">JQuery 使用的就是这种方法，将 JQuery 代码包裹在 (function (window,undefined)&#123;…jquery代码…&#125; (window) 中，在全局作用域中调用 JQuery 代码时，可以达到保护 JQuery 内部变量的作用。</span><br><span class="line"></span><br><span class="line">## 递归</span><br><span class="line">递归函数是在一个函数通过名字调用自身的情况下构成的。</span><br></pre></td></tr></table></figure></p><p>// 递归阶乘函数<br>function factorial(num) {<br>    if (num &lt;= 1) {<br>        return 1;<br>    } else {<br>        return num * factorial(num-1);<br>    }<br>}</p><p>// 用另外一个函数名来使用该阶乘函数，并将 factorial 设置为 null<br>var anotherFactorial = factorial; // 将函数赋值给 anotherFactorial<br>factorial = null;<br>alert(anotherFactorial(4)); // 出错，因为函数定义中使用了自身函数（即指针）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 arguments.callee 来改进，arguments.callee 是一个指向正在执行的函数的指针</span><br></pre></td></tr></table></figure></p><p>function factorial(num) {<br>    if (num &lt;= 1) {<br>        return 1;<br>    } else {<br>        return num * arguments.callee(num-1);<br>    }<br>}</p><p>// 严格模式下，不能通过脚本访问 arguments.callee<br>// 使用命名函数表达式，严格模式和非严格模式都有效<br>var factorial = (function f(num) {<br>    if (num &lt;= 1) {<br>        return 1;<br>    } else {<br>        return num * f(num-1);<br>    }<br>})</p><p>// 创建了一个名为 f() 的命名函数表达式，然后将它赋值给变量 factorial。即便把函数赋值给了另外一个变量，函数名字 f 仍然有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 闭包</span><br></pre></td></tr></table></figure></p><p>function createComparisonFunction(propertyName) {</p><pre><code>return function(object1, object2) {    var value1 = object1[propertyName];    var value2 = object2[propertyName];    if (value1 &lt; value2) {        return -1;    } else if (value1 &gt; value2) {        return 1;    } else {        return 0;    }}</code></pre><p>}</p><p>// 调用<br>var compare = createComparisonFunction(‘age’);<br>compare({age: 15}, {age: 17}); // -1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createComparisonFunction() 返回了一个匿名函数。返回的函数可能会被赋值给一个变量，或者以其他方式被调用。</span><br><span class="line">在把函数当成值来使用的情况下，都可以使用匿名函数，当然这并不是匿名函数的唯一用途。</span><br><span class="line"></span><br><span class="line">## 闭包</span><br><span class="line">变量的作用域分为全局变量和局部变量，局部变量仅在函数内部使用</span><br><span class="line">闭包的核心就是内部函数可以引用外部函数的参数和变量，通过返回函数来扩大函数的作用域。</span><br></pre></td></tr></table></figure></p><p>function first() {<br>    var num = 1;<br>    return function() {<br>        console.log(num);<br>    }<br>}<br>var demo = first();<br>demo();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包可以让一个变量长期驻扎在内存中，避免全局变量的污染</span><br></pre></td></tr></table></figure></p><p>var demo = (function() {<br>     var count = 29;<br>     return function add() {<br>         count++;<br>         console.log(count);<br>     }<br> })();<br> demo(); //30<br> demo(); //31<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闭包传递参数</span><br></pre></td></tr></table></figure></p><p>function first(num) {<br>    return function() {<br>        console.log(num)<br>    }<br>}<br>var demo = first(4); // 相当于  demo = function() {console.log(4)}<br>demo();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义函数如下，定义obj时传入初始x值，obj();执行时，y参数为空，输出NaN，obj(2);执行时，输出6</span><br></pre></td></tr></table></figure></p><p>function Fun(x) {<br>    return function(y) {<br>        console.log(x+y);<br>    }<br>}<br>var obj = Fun(4);<br>// 相当于  obj = function(y) {console.log(4+y)}<br>obj();    //NaN<br>obj(2);   //6<br><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>audio 和 video</title>
      <link href="/2018/01/03/Audio%E5%92%8CVideo/"/>
      <url>/2018/01/03/Audio%E5%92%8CVideo/</url>
      
        <content type="html"><![CDATA[<h2 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h2><h3 id="浏览器的支持情况"><a href="#浏览器的支持情况" class="headerlink" title="浏览器的支持情况"></a>浏览器的支持情况</h3><table><thead><tr><th>浏览器</th><th>MP3</th><th>Wav</th><th>Ogg</th></tr></thead><tbody><tr><td>IE 9+</td><td>√</td><td>×</td><td>×</td></tr><tr><td>Chrome 6+</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Firefox 3.6+</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Safari 5+</td><td>√</td><td>√</td><td>×</td></tr><tr><td>Opera 10+</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>Ogg：一种新的音频压缩格式，是完全免费、开放和没有专利限制的。</p><p>MP3：是一种音频压缩技术。它被设计用来大幅度地降低音频数据量。</p><p>WAV：为微软公司开发的一种声音文件格式，声音文件质量和CD相差无几。</p><h3 id="Audio-的格式"><a href="#Audio-的格式" class="headerlink" title="Audio 的格式"></a>Audio 的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">    &lt;source src=&quot;test.ogg&quot; type=&quot;audio/ogg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;test.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;test.wav&quot; type=&quot;audio/wav&quot;&gt;</span><br><span class="line">    您的浏览器不支持音频播放</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure><h3 id="实际开发中的问题"><a href="#实际开发中的问题" class="headerlink" title="实际开发中的问题"></a>实际开发中的问题</h3><p>Audio 标签 API 其实很简单，但只有 PC 端支持的比较好。移动端因为流量的问题存在各种坑。</p><ol><li><p>自动播放<br>IOS Safari 会忽略 autoplay 属性，原因据官方说明是因为流量的问题，Safari 认为不让用户确认就下载音频文件会引起流量问题，所以禁止了这个功能，除了 IOS，高版本的安卓(5.0)部分机器也存在这个问题。<br>解决方法就是在页面上增加一个按钮，当用户点击按钮时播放音乐</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#myBtn&apos;).on(&apos;touchstart&apos;, function() &#123;</span><br><span class="line">    var audio = $(&apos;#audio&apos;)[0];</span><br><span class="line">    audio.load();</span><br><span class="line">    audio.pause();</span><br><span class="line">    audio.play();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>单例问题<br>估计也是因为流量的问题，IOS Safari 的音频对象是单例的，也就是说你无法播放多个音频文件，当你 load 多个音频时，后一个会覆盖前一个。<br>解决方法就是把两个音频文件合并成一个文件，加载后用过设置声音的位置来播放不同的音乐，类似于 CSS 中的雪碧图。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var audio = $(&apos;#audio&apos;)[0];</span><br><span class="line">audioConfig = &#123;</span><br><span class="line">    // 第一个声音</span><br><span class="line">    sound1: &#123;</span><br><span class="line">        start: 0,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    // 第二个声音</span><br><span class="line">    sound2: &#123;</span><br><span class="line">        start: 1.5,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 播放声音1</span><br><span class="line">audio.currentTime = audioConfig.sound1.start;</span><br><span class="line">audio.play();</span><br><span class="line"></span><br><span class="line">var stopFunc = function() &#123;</span><br><span class="line">    if (this.currentTime &gt;= audioConfig.sound1.start + audioConfig.sound1.length) &#123;</span><br><span class="line">        this.pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 播放声音2</span><br><span class="line">audio.currentTime = audioConfig.sound2.start;</span><br><span class="line">audio.play();</span><br><span class="line"></span><br><span class="line">var stopFunc2 = function() &#123;</span><br><span class="line">    if (this.currentTime &gt;= audioConfig.sound2.start + audioConfig.sound2.length) &#123;</span><br><span class="line">        this.pause()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">audio.addEventListener(&apos;timeupdate&apos;, stopFunc2, false);</span><br></pre></td></tr></table></figure></li><li><p>循环播放<br>部分机型（IOS）循环播放失效。<br>解决方法就是监听播放完成事件，再手动触发播放</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// M4A 是 MPEG-4 音频标准的文件的扩展名,普通的 MPEG4 文件扩展名是“.mp4”</span><br><span class="line">&lt;audio id=&quot;audio&quot; src=&quot;myAudio.m4a&quot; controls&gt;&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line">function loopAudio() &#123;</span><br><span class="line">    var myAudio = document.querySelector(&apos;#audio&apos;);</span><br><span class="line">    myAudio.play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function init() &#123;</span><br><span class="line">    var myAudio = document.querySelector(&apos;#audio&apos;);</span><br><span class="line">    myAudio.addEvemtListener(&apos;ended&apos;, loopAudio, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2><h3 id="浏览器的支持情况-1"><a href="#浏览器的支持情况-1" class="headerlink" title="浏览器的支持情况"></a>浏览器的支持情况</h3><table><thead><tr><th>格式</th><th>IE</th><th>FF</th><th>Opera</th><th>Chrome</th><th>Safari</th></tr></thead><tbody><tr><td>Ogg</td><td>×</td><td>3.5+</td><td>10.5+</td><td>5.0+</td><td>×</td></tr><tr><td>MPEG 4</td><td>9.0+</td><td>×</td><td>×</td><td>5.0+</td><td>3.0+</td></tr><tr><td>WebM</td><td>×</td><td>4.0+</td><td>10.6+</td><td>6.0+</td><td>×</td></tr></tbody></table><p>Ogg：带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</p><p>MPEG 4：带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</p><p>WebM：带有 VP8 视频编码和 Vorbis 音频的 WebM 文件</p><h3 id="Video-的格式"><a href="#Video-的格式" class="headerlink" title="Video 的格式"></a>Video 的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;video src=&quot;video.webm&quot; poster=&quot;img.png&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;test.webm&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;test.mp4&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;test.ogg&quot;&gt;</span><br><span class="line">    &lt;object&gt;这里引入 flash 播放器实现 IE9 以下的，但没必要了&lt;/object&gt;</span><br><span class="line">    您的浏览器不支持视频播放</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="Audio-Video-方法"><a href="#Audio-Video-方法" class="headerlink" title="Audio/Video 方法"></a>Audio/Video 方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>play()</td><td>开始播放音频/视频</td></tr><tr><td>pause()</td><td>暂停当前播放的音频/视频</td></tr><tr><td>load()</td><td>重新加载音频/视频元素</td></tr><tr><td>canPlayType(type)</td><td>检测浏览器是否能播放指定的音频/视频类型</td></tr></tbody></table><h2 id="Audio-Video-属性"><a href="#Audio-Video-属性" class="headerlink" title="Audio/Video 属性"></a>Audio/Video 属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>视频资源的 URL</td></tr><tr><td>width</td><td>视频宽度</td></tr><tr><td>height</td><td>视频高度</td></tr><tr><td>autoplay</td><td>自动播放视频</td></tr><tr><td>preload</td><td>设置或返回音频/视频是否应该在页面加载后进行加载</td></tr><tr><td>controls</td><td>设置或返回音频/视频是否显示控件（浏览器自带）</td></tr><tr><td>loop</td><td>设置或返回音频/视频是否应在结束时重新播放</td></tr><tr><td>poster</td><td>视频封面，没有播放时显示的图片</td></tr><tr><td>ended</td><td>返回音频/视频的播放是否已结束</td></tr><tr><td>paused</td><td>设置或返回音频/视频是否暂停</td></tr><tr><td>muted</td><td>设置或返回音频/视频是否静音</td></tr><tr><td>seeking</td><td>返回用户是否正在音频/视频中进行查找</td></tr><tr><td>volume</td><td>设置或返回音频/视频的音量</td></tr><tr><td>duration</td><td>返回当前音频/视频的长度（以秒计）</td></tr><tr><td>currentSrc</td><td>返回当前音频/视频的 URL</td></tr><tr><td>currentTime</td><td>设置或返回音频/视频中的当前播放位置（以秒计）</td></tr></tbody></table><h2 id="Audio-Video-事件"><a href="#Audio-Video-事件" class="headerlink" title="Audio/Video 事件"></a>Audio/Video 事件</h2><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>pause</td><td>当音频/视频已暂停时</td></tr><tr><td>play</td><td>当音频/视频已开始或不再暂停时</td></tr><tr><td>playing</td><td>当音频/视频在已因缓冲而暂停或停止后已就绪时</td></tr><tr><td>seeked</td><td>当用户已移动/跳跃到音频/视频中的新位置时</td></tr><tr><td>seeking</td><td>当用户开始移动/跳跃到音频/视频中的新位置时</td></tr><tr><td>ended</td><td>当目前的播放列表已结束时</td></tr><tr><td>emptied</td><td>当目前的播放列表为空时</td></tr></tbody></table><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 鼠标移入移出显示和隐藏播放控件</span><br><span class="line">$(&apos;#video&apos;).hover(function()&#123;</span><br><span class="line">    this.controls=true;</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">    this.controls=false;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 当鼠标点击时，视频开始播放</span><br><span class="line">$(&apos;#play&apos;).on(&apos;click&apos;,function()&#123;</span><br><span class="line">    $(&apos;#video&apos;)[0].play(); // play 并不是 jQuery 的函数，而是 DOM 元素的函数，所以我们需要通过 DOM 来调用 play</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&apos;#video&apos;)</span><br><span class="line">    // 播放，播放时，拖动时，播放按钮隐藏</span><br><span class="line">    .on(&apos;play playing seeking&apos;,function()&#123;</span><br><span class="line">        $(&apos;#play&apos;).hide();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    .on(&apos;pause&apos;,function()&#123;</span><br><span class="line">        $(&apos;#play&apos;).show();</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    // 当拖动完成时</span><br><span class="line">    .on(&apos;seeked&apos;,function()&#123;</span><br><span class="line">        if(this.paused) $(&apos;#play&apos;).show();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 播放结束时</span><br><span class="line">    .on(&apos;ended&apos;,function()&#123;</span><br><span class="line">        this.load();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>本文参考至：<a href="https://www.cnblogs.com/zhusheng2008/p/5529439.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhusheng2008/p/5529439.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LocalStorage、SessionStorage、Cookie</title>
      <link href="/2018/01/02/LocalStorage%E3%80%81SessionStorage%E3%80%81Cookie/"/>
      <url>/2018/01/02/LocalStorage%E3%80%81SessionStorage%E3%80%81Cookie/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="设置、获取和删除的方法"><a href="#设置、获取和删除的方法" class="headerlink" title="设置、获取和删除的方法"></a>设置、获取和删除的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 设置cookie</span><br><span class="line">function setCookie(name,value) &#123; </span><br><span class="line">    var Days =1; </span><br><span class="line">    var time = 24 * 60 * 60 * 1000;</span><br><span class="line">    var exp = new Date(); </span><br><span class="line">    exp.setTime(exp.getTime() + time); </span><br><span class="line">    document.cookie = name + &quot;=&quot;+ escape (value) + &quot;;expires=&quot; + exp.toGMTString() +&quot;; path=/&quot;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 读取cookies </span><br><span class="line">function getCookie(name) &#123; </span><br><span class="line">    var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">    if(arr=document.cookie.match(reg))</span><br><span class="line">        return unescape(arr[2]); </span><br><span class="line">    else </span><br><span class="line">        return null; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 删除cookies </span><br><span class="line">function delCookie(name) &#123; </span><br><span class="line">    var exp = new Date(); </span><br><span class="line">    exp.setTime(exp.getTime() - 1); </span><br><span class="line">    var cval=getCookie(name); </span><br><span class="line">    if(cval!=null) </span><br><span class="line">        document.cookie= name + &quot;=&quot;+cval+&quot;;expires=&quot;+exp.toGMTString()+&quot;; path=/&quot;; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 多应用于存储用户 ID，用户名等</span><br><span class="line">setCookie(&quot;id&quot;,res.data.id); </span><br><span class="line">setCookie(&quot;username&quot;,res.data.username); </span><br><span class="line">setCookie(&quot;sessionID&quot;,res.data.sessionID);</span><br></pre></td></tr></table></figure><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>会话：用户打开一个浏览器访问页面，访问网站的很多页面，访问完成后将浏览器关闭的过程称为是一次会话。<br>sessionStorage 对象是用于本地存储一个会话 (session) 中的数据，仅在单个页面（标签或者窗口）会话范围内有效，当会话结束，session 页面关闭后，数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p><h3 id="存储、获取和删除的方法"><a href="#存储、获取和删除的方法" class="headerlink" title="存储、获取和删除的方法"></a>存储、获取和删除的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 存储</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);</span><br><span class="line"></span><br><span class="line">// 获取</span><br><span class="line">sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br><span class="line"></span><br><span class="line">// 清除所有数据</span><br><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 统计页面的访问次数</span><br><span class="line"></span><br><span class="line">if (sessionStorage.count) &#123;</span><br><span class="line">    sessionStorage.count = Number(sessionStorage.count) + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    sessionStorage.count = 1;</span><br><span class="line">&#125;</span><br><span class="line">document.write(&quot;您访问该网站的次数为：&quot; + sessionStorage.count);</span><br></pre></td></tr></table></figure><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage 对象是没有时间限制的数据存储，用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。</p><h3 id="存储、获取和删除的方法-1"><a href="#存储、获取和删除的方法-1" class="headerlink" title="存储、获取和删除的方法"></a>存储、获取和删除的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 存储</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);</span><br><span class="line"></span><br><span class="line">// 获取</span><br><span class="line">sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br><span class="line"></span><br><span class="line">// 清除所有数据</span><br><span class="line">sessionStorage.clear();</span><br></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 统计网站的访问次数</span><br><span class="line"></span><br><span class="line">if (localStorage.count) &#123;</span><br><span class="line">    localStorage.count = Number(localStorage.count) + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    localStorage.count = 1;</span><br><span class="line">&#125;</span><br><span class="line">document.write(&quot;您访问该网站的次数为：&quot; + localStorage.count);</span><br></pre></td></tr></table></figure><h2 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h2><ol><li><p>Cookie 在浏览器和服务器端来回传递数据，而 localStorage 和 sessionStorage 不会自动把数据发送给服务器，仅会保存在本地。Cookie 会在浏览器请求头或者 ajax 请求头中发送 Cookie 内容。</p></li><li><p>Cookie 可以设置失效时间，也是为什么多用于存储登录信息的原因，sessionStorage 是会话级的数据，浏览器窗口关闭即清除，localStorage 是永久性的数据，一旦赋值，不管多长时间这值都是存在的，除非手动清除。</p></li><li><p>Cookie 的存储大小受限制，一般不超过4k，而 localStorage 和 sessionStorage 的存储大小一般不超过5M，大大提高了存储的体积。</p></li><li><p>sessionStorage 不跨窗口，在另外一个窗口打开 sessionStorage 就不存在了，它只在当前窗口有效，而 Cookie 和 localStorage 都是跨窗口的，即使浏览器的窗口关闭，这两个值还是存在的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载</title>
      <link href="/2017/12/03/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2017/12/03/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>实现思路：<br>1.将页面里所有图片的链接用自定义属性 data-xx 代替<br>2.页面加载后只让文档可视区内的图片显示<br>3.当页面滚动直至此图片出现在可视区域时，生成 img 标签，让到可视区的图片加载出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    html,body&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul&#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    li&#123;</span><br><span class="line">        list-style: none;</span><br><span class="line">        width: 20rem;</span><br><span class="line">        height: 24rem;</span><br><span class="line">        border: 1px solid #ccc;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        -webkit-box-sizing: border-box;</span><br><span class="line">        float: left;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    li i&#123;</span><br><span class="line">        width: 20px;</span><br><span class="line">        height: 20px;</span><br><span class="line">        border-radius: 20px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        border: 2px solid #6feb95;</span><br><span class="line">        z-index: 0;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        margin-top: -11px;</span><br><span class="line">        margin-left: -11px;</span><br><span class="line">        animation: move 1s infinite;</span><br><span class="line">        -webkit-animation: move 1s infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    li i:before&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 5px;</span><br><span class="line">        height: 5px;</span><br><span class="line">        border-radius: 4px;</span><br><span class="line">        content: &apos;&apos;;</span><br><span class="line">        box-shadow: 0 0 10px #666;</span><br><span class="line">        -webkit-box-shadow: 0 0 10px #666;</span><br><span class="line">        background: #fff;</span><br><span class="line">        border: 1px solid #fff;</span><br><span class="line">        top: -3px;</span><br><span class="line">        left: 50%;</span><br><span class="line">        margin-left: -3px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    img&#123;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        border-width: 0;</span><br><span class="line">        width: 100%;</span><br><span class="line">        position: relative;</span><br><span class="line">        z-index: 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes move&#123;</span><br><span class="line">        0%&#123;</span><br><span class="line">            transform: rotateZ(0);</span><br><span class="line">        &#125;</span><br><span class="line">        100%&#123;</span><br><span class="line">            transform: rotateZ(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @-webkit-keyframes move&#123;</span><br><span class="line">        0%&#123;</span><br><span class="line">            -webkit-transform: rotateZ(0);</span><br><span class="line">        &#125;</span><br><span class="line">        100%&#123;</span><br><span class="line">            -webkit-transform: rotateZ(360deg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li data-src=&quot;图片地址&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/* 获取节点 */    </span><br><span class="line">var oUl = document.querySelector(&apos;ul&apos;);</span><br><span class="line">var aLi = oUl.querySelectorAll(&apos;li&apos;);</span><br><span class="line"></span><br><span class="line">/* 创建img标签函数 */    </span><br><span class="line">function createImg(obj)&#123;</span><br><span class="line">    var src = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    // 判断是否支持 H5 的 dataset 属性</span><br><span class="line">    if(obj.dataset.src)&#123;</span><br><span class="line">        src = obj.dataset.src;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        src = obj.getAttribute(&apos;data-src&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(obj.children.length &lt;= 1)&#123;</span><br><span class="line">        var img = document.createElement(&apos;img&apos;);</span><br><span class="line">        img.src = src;</span><br><span class="line">        obj.appendChild(img);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 计算节点到文档顶部的距离 */    </span><br><span class="line">function getTop(obj)&#123;</span><br><span class="line">    var h = 0;</span><br><span class="line">    while(obj)&#123;</span><br><span class="line">        h += obj.offsetTop;     // 返回当前元素的相对垂直偏移位置的偏移容器</span><br><span class="line">        obj = obj.offsetParent; // 返回元素的偏移容器</span><br><span class="line">    &#125;</span><br><span class="line">    return h;  </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">/* 滚动实时计算所到区域并进行相关计算 */</span><br><span class="line">window.onscroll = function()&#123;</span><br><span class="line">    // t -&gt; 页面可视区 + 滚动条的高度</span><br><span class="line">    var t = document.documentElement.clientHeight + (document.body.scrollTop || document.documentElement.scrollTop);</span><br><span class="line">    // console.log(t)</span><br><span class="line">    for(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">        // console.log(getTop(aLi[i]))</span><br><span class="line">        if(getTop(aLi[i]) &lt; t)&#123;  </span><br><span class="line">            setTimeout(&apos;createImg(aLi[&apos;+i+&apos;])&apos;,500)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 页面加载完便执行一次滚动函数, 显示在当前可视区的图片 */</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    window.onscroll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件委托</title>
      <link href="/2017/11/30/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2017/11/30/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h2><p>事件委托是通过事件冒泡的原理，利用父级去触发子级的事件。</p><p>下面借鉴网上大牛的取快递的例子来解释事件委托的原理：<br>有三个同事预计会在周一收到快递，为签收快递，有两种办法：一是三个人在公司门口等快递，二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM 收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM 也会在收到寄给新员工的快递后核实并代为签收。</p><p>这里其实还有2层意思：</p><p>第一，员工委托前台的同事是可以代为签收的，即程序中的现有的 DOM 节点是有事件的</p><p>第二，新员工也是可以委托前台MM 代为签收的，即程序中动态添加的 DOM 节点也是有事件的</p><h2 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h2><p>事件委托是通过事件冒泡的原理实现的，而事件冒泡就是事件从最深的节点开始，然后逐步向上传播事件。<br>举个例子：页面上有这么一个节点树，div &gt; ul &gt; li &gt; a<br>给最里面的 a 加一个 click 点击事件，那么这个事件就会一层一层的往外执行，执行顺序a &gt; li &gt; ul &gt; div<br>给最外面的 div 加点击事件，那么里面的 ul， li， a 做点击事件的时候，都会冒泡到最外层的 div 上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><h2 id="为什么要使用事件委托"><a href="#为什么要使用事件委托" class="headerlink" title="为什么要使用事件委托"></a>为什么要使用事件委托</h2><p>一般来说，DOM 需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的 DOM 需要添加事件处理呢？比如我们有 100 个 li，每个 li 都有相同的 click 点击事件，可能我们会用 for 循环的方法，来遍历所有的 li，然后给它们添加事件，那这么做会存在什么影响呢？</p><p>在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与 DOM 节点进行交互，访问 DOM 的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少 DOM 操作的原因；如果用事件委托，就会将所有的操作放到 js 程序里面，与 DOM 的操作就只需要交互一次，这样就能大大的减少与 DOM 的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。</p><h2 id="事件委托的实现"><a href="#事件委托的实现" class="headerlink" title="事件委托的实现"></a>事件委托的实现</h2><p>Event 对象提供了一个属性叫 target，可以返回事件的目标节点，我们称为事件源，也就是说，target 可以表示当前事件操作的 DOM 节点。<br>兼容问题：主流浏览器用 ev.target，IE 浏览器用 event.srcElement。<br>兼容写法：<code>var target = ev.target || event.srcElement</code><br>此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用 nodeName 来获取具体是什么标签名，返回的是一个大写的标签名，也可以先转换成小写，然后进行比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;li&gt;item1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;item2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;item3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;item4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;item5&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            /* </span><br><span class="line">            * 功能：显示当前点击 li 里面的内容</span><br><span class="line">            */ </span><br><span class="line"></span><br><span class="line">            // 普通事件</span><br><span class="line">            $(&apos;li&apos;).click(function()&#123;</span><br><span class="line">                console.log($(this).text());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            // 事件委托</span><br><span class="line">            $(&apos;#wrap&apos;).on(&apos;click&apos;, &apos;li&apos;, function(ev) &#123;</span><br><span class="line">                // this 指向委托的对象 li</span><br><span class="line">                console.log($(this).text());</span><br><span class="line"></span><br><span class="line">                // delegateTarget 返回受委托的DOM元素，即父级的 ul</span><br><span class="line">                console.log($(ev.delegateTarget).html();</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            // JS 普通事件</span><br><span class="line">            window.onload = function()&#123;</span><br><span class="line">                var oUl = document.querySelector(&quot;#wrap&quot;);</span><br><span class="line">                var aLi = oUl.querySelectorAll(&apos;li&apos;);</span><br><span class="line">                for(var i=0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">                    aLi[i].addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">                        console.log(this.innerHTML);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // JS 事件委托</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var oWrap = document.querySelector(&apos;#wrap&apos;);</span><br><span class="line">                oWrap.addEventListener(&apos;click&apos;, function(ev) &#123;</span><br><span class="line">                    var ev = ev || event; // 获取 event 对象的兼容写法</span><br><span class="line">                    console.log(ev.target); // [object HTMLLIElement]</span><br><span class="line">                    if( ev.target.nodeName == &apos;LI&apos; ) &#123;</span><br><span class="line">                        // ev.target 指向匹配对象 li</span><br><span class="line">                        console.log(ev.target.innerHTML); // 点击 li 元素的内容</span><br><span class="line"></span><br><span class="line">                        // this 指向的是父级</span><br><span class="line">                        console.log(this.innerHTML); // 父级元素的内容</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>如果每个被点击的效果都不一样，可以使用 switch 语句来分类进行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;box&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;remove&quot; value=&quot;删除&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;move&quot; value=&quot;移动&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;select&quot; value=&quot;选择&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 常规方法，操作了 4 次 DOM</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            var Add = document.querySelector(&quot;#add&quot;);</span><br><span class="line">            var Remove = document.querySelector(&quot;#remove&quot;);</span><br><span class="line">            var Move = document.querySelector(&quot;#move&quot;);</span><br><span class="line">            var Select = document.querySelector(&quot;#select&quot;);</span><br><span class="line">            </span><br><span class="line">            Add.onclick = function()&#123;</span><br><span class="line">                alert(&apos;添加&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Remove.onclick = function()&#123;</span><br><span class="line">                alert(&apos;删除&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Move.onclick = function()&#123;</span><br><span class="line">                alert(&apos;移动&apos;);</span><br><span class="line">            &#125;;</span><br><span class="line">            Select.onclick = function()&#123;</span><br><span class="line">                alert(&apos;选择&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 事件委托 只用操作 1 次 DOM</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            var oBox = document.querySelector(&quot;#box&quot;);</span><br><span class="line">            oBox.onclick = function (ev) &#123;</span><br><span class="line">                var ev = ev || event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLocaleLowerCase() == &apos;input&apos;)&#123;</span><br><span class="line">                    switch(target.id)&#123;</span><br><span class="line">                        case &apos;add&apos; :</span><br><span class="line">                            alert(&apos;添加&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;remove&apos; :</span><br><span class="line">                            alert(&apos;删除&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;move&apos; :</span><br><span class="line">                            alert(&apos;移动&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                        case &apos;select&apos; :</span><br><span class="line">                            alert(&apos;选择&apos;);</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>以上讲的都是 document 加载完的现有 DOM 节点的操作，那么如果是新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;</span><br><span class="line">    &lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">        &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        // 正常添加节点的方法</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            var oBtn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line">            var oUl = document.querySelector(&quot;#ul1&quot;);</span><br><span class="line">            var aLi = oUl.querySelectorAll(&apos;li&apos;);</span><br><span class="line">            var num = 4;</span><br><span class="line">            </span><br><span class="line">            //鼠标移入变红，移出变白</span><br><span class="line">            for(var i=0; i&lt;aLi.length;i++)&#123;</span><br><span class="line">                aLi[i].addEventListener(&apos;mouseover&apos;, function() &#123;</span><br><span class="line">                    this.style.background = &apos;red&apos;;</span><br><span class="line">                &#125;)</span><br><span class="line">                aLi[i].addEventListener(&apos;mouseout&apos;, function() &#123;</span><br><span class="line">                    this.style.background = &apos;#fff&apos;;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //添加新节点</span><br><span class="line">            oBtn.onclick = function()&#123;</span><br><span class="line">                num++;</span><br><span class="line">                var oLi = document.createElement(&apos;li&apos;);</span><br><span class="line">                oLi.innerHTML = 111*num;</span><br><span class="line">                oUl.appendChild(oLi);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将效果放入包装在函数中，添加新节点时也调用函数</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            var oBtn = document.querySelector(&quot;btn&quot;);</span><br><span class="line">            var oUl = document.querySelector(&quot;ul1&quot;);</span><br><span class="line">            var aLi = oUl.querySelectorAll(&apos;li&apos;);</span><br><span class="line">            var num = 4;</span><br><span class="line">            </span><br><span class="line">            function mHover () &#123;</span><br><span class="line">                //鼠标移入变红，移出变白</span><br><span class="line">                for(var i=0; i&lt;aLi.length;i++)&#123;</span><br><span class="line">                    aLi[i].addEventListener(&apos;mouseover&apos;, function() &#123;</span><br><span class="line">                        this.style.background = &apos;red&apos;;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    aLi[i].addEventListener(&apos;mouseout&apos;, function() &#123;</span><br><span class="line">                        this.style.background = &apos;#fff&apos;;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mHover ();</span><br><span class="line">            //添加新节点</span><br><span class="line">            oBtn.onclick = function()&#123;</span><br><span class="line">                num++;</span><br><span class="line">                var oLi = document.createElement(&apos;li&apos;);</span><br><span class="line">                oLi.innerHTML = 111*num;</span><br><span class="line">                oUl.appendChild(oLi);</span><br><span class="line">                mHover ();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            var oBtn = document.querySelector(&quot;#btn&quot;);</span><br><span class="line">            var oUl = document.querySelector(&quot;#ul1&quot;);</span><br><span class="line">            var aLi = oUl.querySelectorAll(&apos;li&apos;);</span><br><span class="line">            var num = 4;</span><br><span class="line">            </span><br><span class="line">            //事件委托，添加的子元素也有事件</span><br><span class="line">            oUl.addEventListener(&apos;mouseover&apos;, function(ev) &#123;</span><br><span class="line">                var ev = ev || event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">                    target.style.background = &quot;red&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            oUl.addEventListener(&apos;mouseout&apos;, function(ev) &#123;</span><br><span class="line">                var ev = ev || event;</span><br><span class="line">                var target = ev.target || ev.srcElement;</span><br><span class="line">                if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">                    target.style.background = &quot;#fff&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            //添加新节点</span><br><span class="line">            oBtn.onclick = function()&#123;</span><br><span class="line">                num++;</span><br><span class="line">                var oLi = document.createElement(&apos;li&apos;);</span><br><span class="line">                oLi.innerHTML = 111*num;</span><br><span class="line">                oUl.appendChild(oLi);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>如果 li 里面的结构不是固定结构，点击时目标节点有可能不是 li，如果要指定目标节点到 li 上，则需要根据情况进行判断，如下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul id=&quot;test&quot;&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;p&gt;11111111111&lt;/p&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                22222222</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;span&gt;3333333333&lt;/span&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4444444&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">            var oUl = document.querySelector(&apos;#test&apos;);</span><br><span class="line">            oUl.addEventListener(&apos;click&apos;, function(ev) &#123;</span><br><span class="line">                var ev = ev || event;</span><br><span class="line">                var target = ev.target;</span><br><span class="line"></span><br><span class="line">                // 当点击的目标节点不是最外层的 ul 时</span><br><span class="line">                while (target != oUl) &#123;</span><br><span class="line">                    // 如果是 li 就直接执行</span><br><span class="line">                    if (target.tagName == &apos;LI&apos;) &#123;</span><br><span class="line">                        console.log(&apos;li click&apos;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果不是判断元素跟 li 的层级关系，指定到 li 节点上</span><br><span class="line">                    target = target.parentNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>本文参考至：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/5616484.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 威狮堡项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery 的模糊匹配</title>
      <link href="/2017/11/29/%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D/"/>
      <url>/2017/11/29/%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>功能描述：<br>1.点击搜索框，弹出所有内容。<br>2.在搜索框中输入某一个值，可以查询到相关的内容。<br>3.如果查询不到相关的内容，显示没有找到信息。</p><p>实现方法：<br>match() 或者 indexOf() 方法</p><p>实现思路：<br>1.遍历数组，将数据插入到 DOM 节点中<br>2.将输入的值与数组里的每一个对象进行匹配，返回匹配的项，然后插入到 DOM 节点中<br>3.如果数组匹配循环结束后，没有插入项，则插入没有找到信息</p><p>实现难点：<br>1.事件委托<br>2.禁止事件冒泡</p><p>实现代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    ul.searchBox &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">        list-style: none;</span><br><span class="line">        background-color: #666; </span><br><span class="line">        width: 175px;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    ul.searchBox li &#123;</span><br><span class="line">        line-height: 30px;</span><br><span class="line">        padding-left: 10px;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">        color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ul.searchBox li:hover &#123;</span><br><span class="line">        background-color: #999;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    // 模糊搜索框</span><br><span class="line">    &lt;input id=&quot;search&quot; type=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line">    // 搜索内容下拉列表</span><br><span class="line">    &lt;ul class=&quot;searchBox&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            // 模拟后台返回数据数组</span><br><span class="line">            var xiaoqu = [&apos;阳光小区&apos;, &apos;万科四季&apos;, &apos;博雅西园&apos;];</span><br><span class="line"></span><br><span class="line">            // 点击消失</span><br><span class="line">            $(document).on(&apos;click&apos;, function() &#123;</span><br><span class="line">                $(&apos;.searchBox&apos;).css(&apos;display&apos;,&apos;none&apos;);</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            // 点击搜索框时，展示所有的数据</span><br><span class="line">            $(&apos;#search&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class="line">                $(&apos;.searchBox&apos;).children().remove();</span><br><span class="line">                $(&apos;.searchBox&apos;).css(&apos;display&apos;,&apos;block&apos;);</span><br><span class="line"></span><br><span class="line">                var tmpHtml = &apos;&apos;;</span><br><span class="line">                for (var i=0; i&lt;xiaoqu.length; i++) &#123;</span><br><span class="line">                    tmpHtml += &apos;&lt;li&gt;&apos;+ xiaoqu[i] +&apos;&lt;/li&gt;&apos;</span><br><span class="line">                &#125;</span><br><span class="line">                $(&apos;.searchBox&apos;).append(tmpHtml);</span><br><span class="line">                return false; // 禁止事件冒泡</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 监听 input 输入框的变化</span><br><span class="line">            $(&apos;#search&apos;).on(&apos;input&apos;, function() &#123;</span><br><span class="line">                $(&apos;.searchBox&apos;).children().remove(); // 去除上一次的搜索内容</span><br><span class="line">                $(&apos;.searchBox&apos;).css(&apos;display&apos;,&apos;block&apos;);</span><br><span class="line"></span><br><span class="line">                if ($(this).val() == &apos;&apos;) &#123;</span><br><span class="line">                    var tmpHtml = &apos;&apos;;</span><br><span class="line">                    for (var i=0; i&lt;xiaoqu.length; i++) &#123;</span><br><span class="line">                        tmpHtml += &apos;&lt;li&gt;&apos;+ xiaoqu[i] +&apos;&lt;/li&gt;&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    $(&apos;.searchBox&apos;).append(tmpHtml);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    for (var i=0; i&lt;xiaoqu.length; i++) &#123;</span><br><span class="line">                        // indexOf() 方法，-1 即不存在</span><br><span class="line">                        // if (xiaoqu[i].indexOf($(this).val()) != -1) &#123;</span><br><span class="line">                        //     执行代码</span><br><span class="line">                        // &#125;</span><br><span class="line">        </span><br><span class="line">                        // match() 方法，null 即不存在</span><br><span class="line">                        var tmpHtml = &apos;&apos;;</span><br><span class="line">                        if (xiaoqu[i].match($(this).val()) != null) &#123;</span><br><span class="line">                            tmpHtml += &apos;&lt;li&gt;&apos;+ xiaoqu[i] +&apos;&lt;/li&gt;&apos;;</span><br><span class="line">                        &#125; </span><br><span class="line">                        console.log(tmpHtml)  </span><br><span class="line">                        $(&apos;.searchBox&apos;).append(tmpHtml); </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // 循环结束还没有匹配到则显示“没有找到该小区”</span><br><span class="line">                    if ($(&apos;.searchBox&apos;).children().length == 0) &#123;</span><br><span class="line">                        $(&apos;.searchBox&apos;).append(&apos;&lt;li&gt;没有找到该小区&lt;/li&gt;&apos;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            // 如果列表是静态的可以触发 但是节点是动态添加的就触发不了</span><br><span class="line">            // 因为添加子节点的时候，事件没有一起添加进去</span><br><span class="line">            // $(&apos;.searchBox li&apos;).on(&apos;click&apos;, function() &#123;</span><br><span class="line">            //     $(&apos;#search&apos;).val($(this).text());</span><br><span class="line">            // &#125;)</span><br><span class="line"></span><br><span class="line">            // 采用事件委托，不管动态添加还是静态都能够触发</span><br><span class="line">            $(&apos;.searchBox&apos;).on(&apos;click&apos;, &apos;li&apos;, function() &#123;</span><br><span class="line">                $(&apos;#search&apos;).val($(this).text());</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;) </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 威狮堡项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类型</title>
      <link href="/2017/11/27/Object%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/27/Object%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>引用类型的值（又称对象）是引用类型的一个实例。<br>在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。<br>引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p><p>新对象是使用 new 操作符跟一个构造函数来创建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 赋值操作符表示后面是一个值</span><br><span class="line">// 创建了 Object 引用类型的一个新实例，然后把该实例保存在了变量 person 中</span><br><span class="line">var person = new Object();</span><br><span class="line">var person = 值/引用类型的值/对象</span><br></pre></td></tr></table></figure><h2 id="创建-Object-实例"><a href="#创建-Object-实例" class="headerlink" title="创建 Object 实例"></a>创建 Object 实例</h2><p>我们看到的大多数引用类型值都是 Object 类型的实例，用于程序中存储和传输数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = &apos;John&apos;;</span><br><span class="line">person.age = 22;</span><br><span class="line"></span><br><span class="line">// 对象字面量，目的在于简化创建包含大量属性的对象</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    age: 22</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用对象字面量语法时，属性名也可以使用字符串</span><br><span class="line">var person = &#123;</span><br><span class="line">    &apos;name&apos;: &apos;John&apos;,</span><br><span class="line">    &apos;age&apos;: 22,</span><br><span class="line">    5: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果是空花括号，则可以定义只包含默认属性和方法的对象</span><br><span class="line">var person = &#123;&#125;; // 与 new Object() 相同</span><br><span class="line">person.name = &apos;John&apos;;</span><br><span class="line">person.age = 22</span><br></pre></td></tr></table></figure><p>在对象字面量中，左边的 ‘{’ 表示对象字面量的开始，因为它出现在了表达式上下文中。<br>ECMAScript 中的表达式上下文指的是该上下文期待一个值（表达式）。<br>赋值操作符表示后面是一个值，所以 ‘{’ 在这里表示一个表达式的开始。<br>同样的一个 ‘{’，如果出现在一个语句上下文中，例如跟在 if 语句条件的后面，则表示一个语句块的开始。</p><p>对象字面量向函数传递大量可选参数的首选方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function displayInfo(args) &#123;</span><br><span class="line">    var output = &apos;&apos;;</span><br><span class="line">    </span><br><span class="line">    if (typeof args.name == &apos;string&apos;) &#123;</span><br><span class="line">        output += &apos;Name:&apos;+ args.name + &apos;\n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof args.age == &apos;number&apos;) &#123;</span><br><span class="line">        output += &apos;Age:&apos;+ args.age + &apos;\n&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayInfo(&#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    age:　22</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">displayInfo(&#123;</span><br><span class="line">    name: &apos;mary&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下回显示不够灵活。最好的做法是对那些必须值使用命名参数，而使用对象字面量来封装多个可选参数。</p><h2 id="点表示法和方括号表示法"><a href="#点表示法和方括号表示法" class="headerlink" title="点表示法和方括号表示法"></a>点表示法和方括号表示法</h2><p>一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。<br>不过，在 JavaScript 中也可以使用方括号表示法来访问对象的属性。<br>在使用方括号语言时，应该将要访问的属性以字符串的形式放在方括号中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alert(person[&apos;name&apos;]); // &apos;John&apos;</span><br><span class="line">alert(preson.name);    // &apos;John&apos;</span><br><span class="line"></span><br><span class="line">// 方括号的优点是可以通过变量来访问属性</span><br><span class="line">var propertyName = &apos;name&apos;;</span><br><span class="line">alert(person[propertyName]); // &apos;John&apos;</span><br><span class="line"></span><br><span class="line">// 如果属性名包含会导致语法错误的字符，或者属性名使用的是关键字或保留字</span><br><span class="line">person[&apos;first name&apos;] = &apos;John&apos;</span><br></pre></td></tr></table></figure><p>PS：通常，除非必须使用变量来访问属性，否则建议使用点表示法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单体内置对象</title>
      <link href="/2017/11/23/%E5%8D%95%E4%BD%93%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
      <url>/2017/11/23/%E5%8D%95%E4%BD%93%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 对内置对象的定义是：<br>由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。即不必显式地实例化内置对象，因为它们已经实例化了。<br>内置对象，如 Object、Array 何 String。除此之外，ECMA-262 还定义了两个单体内置对象：Global 和 Math。</p><h2 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h2><p>Global 对象在某种意义上市作为一个中级的“兜底儿对象”来定义的。换句话说，Global 不属于任何其他对象的属性和方法，最终都是它的属性和方法。<br>事实上，没有全局变量和全局函数，所有的全局作用域中定义的属性和函数，都是 Gloval 对象的属性，如 isNaN()、 isFinite()、 parseInt() 以及 parseFloat()</p><h3 id="URI-编码方法"><a href="#URI-编码方法" class="headerlink" title="URI 编码方法"></a>URI 编码方法</h3><p>Global 对象的 encodeURI() 和 encodeURIComponent() 方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。<br>有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对 URI 进行编码，用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。<br>encodeURI() 主要用于整个 URI（例如，<a href="http://www.wrox.com/illegal" target="_blank" rel="noopener">http://www.wrox.com/illegal</a> value.html）进行编码<br>encodeURIComponent() 主要用于对 URI 中的某一段（例如前面 URI 中的 illegal value.html）进行编码<br>decodeURI() 只能对 encodeURI() 替换的字符进行解码<br>decodeURIComponent() 对 encodeURIComponent() 进行解码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var uri = &apos;http://www.wrox.com/illegal value.html#start&apos;;</span><br><span class="line"></span><br><span class="line">// http://www.wrox.com/illegal%20value.html#start</span><br><span class="line">alert(encodeURI(uri)); // 不会对本身属于 URI 的特殊字符进行编码，如 : / ? #</span><br><span class="line"></span><br><span class="line">// http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start</span><br><span class="line">alert(encodeURIComponent(uri)); // 对应的编码替换所有非字母数字字符</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### eval() 方法</span><br><span class="line">eval() 方法就像一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript （或 JavaScript）字符串。</span><br></pre></td></tr></table></figure><p>// 将传入的参数当作实际的 ECMAScript 语句来解析<br>eval(‘alert(‘hi’)’); // 作用等价于 alert(‘hi’)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### window 对象</span><br><span class="line">在全局作用域中的所有变量和函数都是 window 对象的属性。</span><br></pre></td></tr></table></figure></p><p>var color = ‘red’;</p><p>function sayColor() {<br>    alert(window.color);<br>}</p><p>window.sayColor(); // ‘red’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Math 对象</span><br><span class="line">### Math 对象的属性</span><br><span class="line"></span><br><span class="line">属性 | 说明</span><br><span class="line">---- | ---</span><br><span class="line">Math.E | 自然对数的底数，即常量 e 的值</span><br><span class="line">Math.LN10 | 10 的自然对数</span><br><span class="line">Math.LN2 | 2 的自然对数</span><br><span class="line">Math.LOG2E | 以 2 为底 e 的对数</span><br><span class="line">Math.LOG10E | 以 10 为底 e 的对数</span><br><span class="line">Math.PI | π 的值</span><br><span class="line"></span><br><span class="line">### min() 和 max() 方法</span><br><span class="line">min() 和 max() 方法用于确定一组数值中的最小值和最大值。</span><br></pre></td></tr></table></figure></p><p>var max = Math.max(3, 54, 32, 16);<br>alert(max); // 54</p><p>var min = Math.min(3, 54, 32, 16);<br>alert(min); // 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要找到数组中的最大或最小值，还可以使用 apply() 方法</span><br></pre></td></tr></table></figure></p><p>// 把 Math 对象作为 apply() 的第一个参数，从而正确的设置 this 值<br>var values = [1, 2, 3, 4, 5, 6, 7, 8];<br>var max = Math.max.apply(Math, values);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 舍入方法</span><br><span class="line">- Math.ceil() 执行向上舍入</span><br><span class="line">- Math.floor() 执行向下舍入</span><br><span class="line">- Math.round() 执行标准舍入，即四舍五入</span><br></pre></td></tr></table></figure></p><p>alert(Math.ceil(25.9)); // 26<br>alert(Math.ceil(25.5)); // 26<br>alert(Math.ceil(25.1)); // 26</p><p>alert(Math.floor(25.9)); // 25<br>alert(Math.floor(25.5)); // 25<br>alert(Math.floor(25.1)); // 25</p><p>alert(Math.round(25.9)); // 26<br>alert(Math.round(25.5)); // 26<br>alert(Math.round(25.1)); // 25<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### random() 方法</span><br><span class="line">Math.random() 方法返回大于等于 0 小于 1 的一个随机数，还是个小数。</span><br></pre></td></tr></table></figure></p><p>// 从某个整数范围内随机选择一个值<br>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</p><p>// 选择一个介于 2 到 10 之间的值，可能值的总数是 9<br>var num = Math.floor(Math.random() * 9 + 2); // 第一个可能的值是 2</p><p>function selectFrom(lowerValue, upperValue) {<br>    var choices = upperValue - lowerValue + 1;<br>    return Math.floor(Math.random() * choices + lowerValue);<br>}</p><p>var num = selectFrom(2, 10);<br>alert(num); // 介于 2 到 10 之间（包括 2 和 10）的一个数值</p><p>// 利用函数，从数组中随机取出一项<br>var colors = [‘red’, ‘green’, ‘black’];<br>var color = colors[selectFrom(0, colors.length-1)];<br>alert(color); // 可能是数组中包含的任何一个字符串<br><code>`</code></p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Math.abs(num)</td><td>返回 num 的绝对值</td></tr><tr><td>Math.exp(num)</td><td>返回 Math.E 的 num 次幂</td></tr><tr><td>Math.log(num)</td><td>返回 num 的自然对数</td></tr><tr><td>Math.pow(num,power)</td><td>返回 num 的 power 次幂</td></tr><tr><td>Math.sqrt(num)</td><td>返回 num 的平方根</td></tr><tr><td>Math.acos(x)</td><td>返回 x 的反余弦值</td></tr><tr><td>Math.asin(x)</td><td>返回 x 的反正弦值</td></tr><tr><td>Math.atan(x)</td><td>返回 x 的反正切值</td></tr><tr><td>Math.atan2(y,x)</td><td>返回 y/x 的反正切值</td></tr><tr><td>Math.cos(x)</td><td>返回 x 的余弦值</td></tr><tr><td>Math.sin(x)</td><td>返回 x 的正弦值</td></tr><tr><td>Math.tan(x)</td><td>返回 x 的正切值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本包装类型</title>
      <link href="/2017/11/20/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/20/%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>为了便于操作基本类型值，ECMAScript 提供了 3 个特殊的引用类型： Boolean、 Number 和 String。<br>这些类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。<br>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;some text&apos;; // 字符串是基本类型值，并不是对象</span><br><span class="line">var s2 = s1.substring(2);</span><br></pre></td></tr></table></figure><p>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而读取模式中访问字符串时，后台都会自动完成下列处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）创建 String 类型的一个实例;</span><br><span class="line">（2）在实例上调用指定的方法;</span><br><span class="line">（3）销毁这个实例。</span><br><span class="line"></span><br><span class="line">var s1 = new String(&apos;some text&apos;); // 基本类型实例</span><br><span class="line">var s2 = s1.substring(2);</span><br><span class="line">s1 = null;</span><br></pre></td></tr></table></figure></p><p>引用类型与基本包装类型的主要区别就是对象的生存期。<br>使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。<br>这意味着我们不能在运行时为基本类型值添加属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s1 = &apos;some text&apos;;</span><br><span class="line">s1.color = &apos;red&apos;; </span><br><span class="line">alert(s1.color); // undefined</span><br></pre></td></tr></table></figure><p>第二行创建的 String 对象在执行到第三行代码时已经被销毁了。<br>第三行代码又创建了自己的 String 对象，而该对象没有 color 属性。</p><p>可以显式地调用 Boolean、 Number 和 String 来创建基本包装类型的对象。<br>但是这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。</p><font style="color: red">对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值 true。 </font><p>Obeject 构造函数也像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object(&apos;some text&apos;); // 自动创建 String 的实例</span><br><span class="line">alert(obj instanceof String); // true</span><br></pre></td></tr></table></figure></p><p>注意：使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var value = &apos;25&apos;;</span><br><span class="line">var number = Number(value);  // 转型函数 保存的是基本类型</span><br><span class="line">alert(typeof number);        // number</span><br><span class="line"></span><br><span class="line">var obj = new Number(value); // 构造函数 保存的是 Number 的实例</span><br><span class="line">alert(typeof obj);           // object</span><br></pre></td></tr></table></figure></p><h2 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h2><p>Boolean 类型是与布尔值对应的引用类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var booleanObject = new Boolean();     // 默认是 false</span><br><span class="line">var booleanObject = new Boolean(true); // true</span><br></pre></td></tr></table></figure></p><p>Boolean 类型的实例重写了 valueOf() 方法，返回基本类型值 true 或 false，重写了 toString() 方法，返回字符串 “true” 或 “false”。</p><p>Boolean 对象在 ECMAScript 中的用处不大，因为它常会造成人们的误解。<br>最常见的问题就是在布尔表达式中使用 Boolean 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var falseObject = new Boolean(false);</span><br><span class="line">// 与基本类型值 true 构成了逻辑与表达式</span><br><span class="line">var result = falseObject &amp;&amp; true; // 基本包装类型的对象都会被转换成布尔值的 true</span><br><span class="line">alert(result); // true</span><br><span class="line"></span><br><span class="line">var falseValue = false;</span><br><span class="line">// 布尔运算中，false &amp;&amp; true 等于 false</span><br><span class="line">result = falseValue &amp;&amp; true;</span><br><span class="line">alert(result); // false</span><br></pre></td></tr></table></figure><p>基本类型与引用类型的布尔值有两个区别：</p><ul><li>tyoeof 操作符对基本类型返回 “boolean”，而对引用类型返回 “object”</li><li>由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof falseObject); // object</span><br><span class="line">alert(typeof falseValue);  // boolean</span><br><span class="line">alert(falseObject instanceof Boolean); // true</span><br><span class="line">alert(falseValue instanceof Boolean);  // false</span><br></pre></td></tr></table></figure><p>理解基本类型的布尔值与 Boolean 对象之间的区别非常重要——当然，建议是永远不要使用 Boolean 对象。</p><h2 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h2><p>Number 是与数字值对应的引用类型、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建 Number 对象，同时给 Number 构造函数传递响应的数值</span><br><span class="line">var numberObject = new Number(10);</span><br></pre></td></tr></table></figure><p>Number 类型也重写后 valueOf() 方法返回对象表示的基本类型的数值，另外两个 toLocaleString() 和 toString() 方法返回字符串形式的数值。</p><p>可以为 toString() 方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString());   // &quot;10&quot;</span><br><span class="line">alert(num.toString(2));  // &quot;1010&quot;</span><br><span class="line">alert(num.toString(8));  // &quot;12&quot;</span><br><span class="line">alert(num.toString(10)); // &quot;10&quot;</span><br><span class="line">alert(num.toString(16)); // &quot;a&quot;</span><br></pre></td></tr></table></figure><p>除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。</p><h3 id="toFixed-方法"><a href="#toFixed-方法" class="headerlink" title="toFixed() 方法"></a>toFixed() 方法</h3><p>toFixed() 方法会按照指定的小数位返回数值的字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toFixed(2)); // &apos;10.00&apos;</span><br><span class="line"></span><br><span class="line">// 如果数值本身包含的小数位比指定的多，则接近指定的最大小数位的值就会舍入</span><br><span class="line">var num = 10.005;</span><br><span class="line">alert(num.toFixed(2)); // &apos;10.01&apos;</span><br></pre></td></tr></table></figure></p><h3 id="toExponential-方法"><a href="#toExponential-方法" class="headerlink" title="toExponential() 方法"></a>toExponential() 方法</h3><p>toExponential() 方法返回指数表示法（也称 e 表示法）的字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 一般用来表示数值比较大的数</span><br><span class="line">var num = 10;</span><br><span class="line">alert(num.toExponential(1)); // &apos;1.0e+1&apos;</span><br></pre></td></tr></table></figure></p><h3 id="toPrecision-方法"><a href="#toPrecision-方法" class="headerlink" title="toPrecision() 方法"></a>toPrecision() 方法</h3><p>对于一个数值来说，toPrecision() 方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式。<br>该方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = 99;</span><br><span class="line">alert(num.toPrecision(1)); // &apos;1e+2&apos; 1 乘以 10 的 2 次方</span><br><span class="line">alert(num.toPrecision(2)); // &apos;99&apos;</span><br><span class="line">alert(num.toPrecision(3)); // &apos;99.0&apos;</span><br></pre></td></tr></table></figure><p>与 Boolean 对象类似，不建议直接实例化 Number 类型，原因与显创建 Boolean 对象一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numberObject = new Number(10);</span><br><span class="line">var numberValue = 10;</span><br><span class="line"></span><br><span class="line">alert(typeof numberObject); // &apos;object&apos;</span><br><span class="line">alert(typeof numberValue);  // &apos;number&apos;</span><br><span class="line">alert(numberObject instanceof Number); // true</span><br><span class="line">alert(numberValue instanceof Number);  // false</span><br></pre></td></tr></table></figure></p><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>String 对象的方法也可以在所有基本的字符串只中访问到。<br>继承的 valueOf()、toLocaleString() 和 toString() 方法，都返回对象所表示的基本字符串值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 使用 String 构造函数来创建</span><br><span class="line">var stringObject = new String(&apos;hello world&apos;);</span><br></pre></td></tr></table></figure></p><p>String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。<br>即使字符串中包含双字节字符（不是占一个字节的 ASCⅡ 字符），每个字符也仍然算一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue.length); // &apos;11&apos;</span><br><span class="line"></span><br><span class="line">// 单字节指只占一个字，是英文字符。双字是占两个字节的，中文字符都占两个字节。</span><br><span class="line">var stringValue = &apos;嗨 world&apos;;</span><br><span class="line">alert(stringValue.length); // &apos;7&apos;</span><br></pre></td></tr></table></figure></p><h2 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h2><h3 id="charAt-和-charCodeAt-方法"><a href="#charAt-和-charCodeAt-方法" class="headerlink" title="charAt() 和 charCodeAt() 方法"></a>charAt() 和 charCodeAt() 方法</h3><p>这两个方法都接收一个参数，即基于 0 的字符位置。<br>charAt() 方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript 中没有字符类型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue.charAt(1)); // &apos;e&apos;</span><br><span class="line"></span><br><span class="line">// 如果想返回的是字符编码</span><br><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue.charCodeAt(1)); // &apos;101&apos; 小写字母 &apos;e&apos; 的字符编码</span><br></pre></td></tr></table></figure></p><p>ECMAScript 5 还定义了另一个访问个别字符的方法。<br>可以使用方括号加数字索引来访问字符串中的特定字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue[1]); // &apos;e&apos;</span><br></pre></td></tr></table></figure></p><p>支持浏览器有 IE8+ 以及各主流浏览器，早起版本使用将会返回 undefined 值。</p><h2 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h2><h3 id="concat-方法"><a href="#concat-方法" class="headerlink" title="concat() 方法"></a>concat() 方法</h3><p>concat() 方法用于将一或多个字符串拼接起来，返回拼接得到的新字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello &apos;;</span><br><span class="line">var result = stringValue.concat(&apos;world&apos;);</span><br><span class="line"></span><br><span class="line">alert(result);      // &apos;hello world&apos;</span><br><span class="line">alert(stringValue); // &apos;hello&apos; 对原字符串没有任何影响</span><br><span class="line"></span><br><span class="line">// 拼接多个字符串</span><br><span class="line">var stringValue = &apos;hello &apos;;</span><br><span class="line">var result = stringValue.concat(&apos;world&apos;, &apos;!&apos;);</span><br><span class="line"></span><br><span class="line">alert(result);      // &apos;hello world!&apos;</span><br><span class="line">alert(stringValue); // &apos;hello&apos;</span><br></pre></td></tr></table></figure></p><p>虽然 concat() 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。</p><h3 id="slice-、-substr-、-substring-方法"><a href="#slice-、-substr-、-substring-方法" class="headerlink" title="slice()、 substr()、 substring() 方法"></a>slice()、 substr()、 substring() 方法</h3><p>三个基于子字符串创建新字符串的方法：slice()、 substr()、 substring()<br>这三个方法都会返回被操作字符串的一个子字符串，而且都接收一或两个参数。<br>如果没有传递第二个参数，则将字符串的长度作为结束位置返回。<br>slice(指定子字符串的开始位置，子字符串的最后一个字符后面的位置)<br>substring(指定子字符串的开始位置，子字符串的最后一个字符后面的位置)<br>substr(指定子字符串的开始位置，返回的字符个数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;    // </span><br><span class="line">alert(stringValue.slice(3));        // &apos;lo world&apos;</span><br><span class="line">alert(stringValue.substring(3));    // &apos;lo world&apos;</span><br><span class="line">alert(stringValue.substr(3));       // &apos;lo world&apos;</span><br><span class="line"></span><br><span class="line">alert(stringVlaue.slice(3, 7));     // &apos;lo w&apos;</span><br><span class="line">alert(stringVlaue.substring(3, 7)); // &apos;lo w&apos;</span><br><span class="line">alert(stringVlaue.substr(3, 7));    // &apos;lo worl&apos;</span><br></pre></td></tr></table></figure><p>如果传递的参数是赋值，则：<br>slice() 方法会将传递的负值与字符串的长度相加<br>substring() 方法会将所有的负值参数都转换为 0<br>substr() 方法将负的第一个参数与字符串的长度相加，而负的第二个参数转换为 0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;   </span><br><span class="line">alert(stringValue.slice(-3));        // &apos;rld&apos;</span><br><span class="line">alert(stringValue.substring(-3));    // &apos;hello world&apos;</span><br><span class="line">alert(stringValue.substr(-3));       // &apos;rld&apos;</span><br><span class="line">  </span><br><span class="line">alert(stringVlaue.slice(3, -4));     // &apos;lo w&apos;</span><br><span class="line">alert(stringVlaue.substring(3, -4)); // &apos;hel&apos;</span><br><span class="line">alert(stringVlaue.substr(3, -4));    // &apos;&apos;（空字符串）</span><br></pre></td></tr></table></figure><p>substring(3, -4) 变成 substring(3, 0),但因为这个方法会将较小的数作为开始位置，将较大的数作为结束位置，因此最终相当于调用了 substring(0, 3)。</p><h2 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h2><h3 id="indexOf-和-lastIndexOf-方法"><a href="#indexOf-和-lastIndexOf-方法" class="headerlink" title="indexOf() 和 lastIndexOf() 方法"></a>indexOf() 和 lastIndexOf() 方法</h3><p>indexOf() 和 lastIndexOf() 方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果眉头找到该字符串，则返回 -1）。<br>indexOf() 是从字符串的开头向后搜索子字符串。<br>lastIndexOf() 是从字符串的末尾向前搜索子字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue.indexOf(&apos;o&apos;));     // 4</span><br><span class="line">alert(stringValue.lastIndexOf(&apos;o&apos;)); // 7</span><br><span class="line"></span><br><span class="line">// 第二个参数表示从字符串中的哪个位置开始搜索</span><br><span class="line">alert(stringValue.indexOf(&apos;o&apos;, 6));     // 7</span><br><span class="line">alert(stringValue.lastIndexOf(&apos;o&apos;, 6)); // 4</span><br></pre></td></tr></table></figure></p><p>在使用第二个参数的情况下，可以通过循环调用 indexOf() 或 lastIndexOf() 来找到所有匹配的子字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">var positions = new Array(); // 创建一个数组储存结果</span><br><span class="line">var pos = stringValue.indexOf(&apos;l&apos;); // 获取 &apos;l&apos; 的第一个位置</span><br><span class="line"></span><br><span class="line">while (pos &gt; -1) &#123;</span><br><span class="line">    positions.push(pos); // 将值放进创建的空数组中</span><br><span class="line">    pos = stringValue.indexOf(&apos;l&apos;, pos + 1); // 从搜索到的后一个位置继续开始搜索</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(positions); // &apos;2,3,9&apos;</span><br></pre></td></tr></table></figure></p><h2 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim() 方法"></a>trim() 方法</h2><p>ECMAScript 定义了 trim() 方法，这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;    hello world    &apos;;</span><br><span class="line">var trimmedStringValue = stringValue.trim();</span><br><span class="line">alert(stringValue);        // &apos;    hello world    &apos;</span><br><span class="line">alert(trimmedStringValue); // &apos;hello world&apos;</span><br></pre></td></tr></table></figure></p><p>支持这个方法的浏览器有 IE9+ 以及主流浏览器。</p><h2 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h2><p>toLowerCase()、 toUpperCase() 一组经典的大小写转换方法。<br>toLocaleLowerCase()、 toLocaleUpperCase() 针对特定地区的实现。<br>一般来说，在不知道自己的代码将在那种语言环境中运行的情况下，还是使用针对地区的方法稳妥点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;hello world&apos;;</span><br><span class="line">alert(stringValue.toUpperCase()); // &apos;HELLO WORLD&apos;</span><br><span class="line">alert(stringValue.toLowerCase()); // &apos;hello world&apos;</span><br></pre></td></tr></table></figure><h2 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h2><h3 id="match-方法"><a href="#match-方法" class="headerlink" title="match() 方法"></a>match() 方法</h3><p>stringObject.match(searchvalue)<br>stringObject.match(regexp)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回指定的值，没有则为 null</span><br><span class="line">var stringValue = &apos;Hello World!&apos;;</span><br><span class="line">alert(stringValue.match(&apos;Hello&apos;)); // Hello</span><br><span class="line">alert(stringValue.match(&apos;hello&apos;)); // null</span><br><span class="line"></span><br><span class="line">// 返回正则表达式的匹配值</span><br><span class="line">var stringValue=&quot;1 plus 2 equal 3&quot;</span><br><span class="line">alert(stringValue.match(/\d+/g)); // 1,2,3</span><br></pre></td></tr></table></figure><h3 id="search-方法"><a href="#search-方法" class="headerlink" title="search() 方法"></a>search() 方法</h3><p>search() 方法返回字符串中第一个匹配项的索引，如果没有找到匹配项，则返回 -1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回匹配项的位置的索引，没有则为 -1</span><br><span class="line">var stringValue = &apos;Hello World!&apos;;</span><br><span class="line">alert(stringValue.search(&apos;Hello&apos;)); // 0</span><br><span class="line">alert(stringValue.search(&apos;hello&apos;)); // -1</span><br><span class="line"></span><br><span class="line">// 返回正则表达式的匹配位置的索引</span><br><span class="line">var stringValue=&quot;plus 2 equal 3&quot;</span><br><span class="line">alert(stringValue.search(/\d+/g)); // 5</span><br></pre></td></tr></table></figure></p><h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace() 方法"></a>replace() 方法</h3><p>replace(RegExp对象或一个字符串，一个字符串或者一个函数)<br>如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有的子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var result = text.replace(&apos;at&apos;, &apos;ond&apos;);</span><br><span class="line">alert(result); // &apos;cond, bat, sat, fat&apos;</span><br><span class="line"></span><br><span class="line">result = text.replace(/at/g, &apos;ond&apos;);</span><br><span class="line">alert(result); // &apos;cond, bond, sond, fond&apos;</span><br></pre></td></tr></table></figure><p>如果第二个参数是字符串，还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。<br>下标列出了 ECMAScript 提供的这些特殊的字符序列。</p><table><thead><tr><th>字符序列</th><th>替换文本</th></tr></thead><tbody><tr><td>$$</td><td>$</td></tr><tr><td>$&amp;</td><td>匹配整个模式的子字符串。与 RegExp.lastMatch 的值相同</td></tr><tr><td>$’</td><td>匹配的子字符串之前的子字符串。与 RegExp.leftContext 的值相同</td></tr><tr><td>$`</td><td>匹配的子字符串之后的子字符串。与 RegExp.rightContext 的值相同</td></tr><tr><td>$n</td><td>匹配第 n 个捕获组的子字符串，其中 n 等于 0~9。例如，$1 是匹配第一个捕获组的子字符串，$2 是匹配第二个捕获组的子字符串</td></tr><tr><td>$nn</td><td>匹配第 nn 个捕获组的子字符串，其中 n 等于 0~99。例如，$01 是匹配第一个捕获组的子字符串，$02 是匹配第二个捕获组的子</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">result = text.replace(/(.at)/g, &apos;word($1)&apos;);</span><br><span class="line">alert(result); // word(cat), word(bat), word(sat), word(fat)</span><br></pre></td></tr></table></figure><p>replace() 方法的第二个参数也可以是一个函数。<br>在只有一个匹配项（即与模式匹配的字符串）的情况下，回向这个函数传递 3 个参数。<br>如果正则表达式定义了多个捕获组的情况下，传递参数依次是模式的匹配项、第一个捕获组的匹配项······，模式匹配项在字符串中的位置，原始字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function(模式的匹配项，模式匹配项在字符串中的位置，原始字符串) &#123;</span><br><span class="line">    执行内容</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function htmlEscape (text) &#123;</span><br><span class="line">    return text.replace(/[&lt;&gt;&quot;&amp;]/g, function(match, post, originalText) &#123;</span><br><span class="line">        switch(match) &#123;</span><br><span class="line">            case &apos;&lt;&apos;:</span><br><span class="line">                return &apos;&amp;lt;&apos;;</span><br><span class="line">            case &apos;&gt;&apos;:</span><br><span class="line">                return &apos;&amp;gt;&apos;;</span><br><span class="line">            case &apos;&amp;&apos;:</span><br><span class="line">                return &apos;&amp;amp;&apos;;</span><br><span class="line">            case &apos;\&quot;&apos;:</span><br><span class="line">                return &apos;&amp;quot;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(htmlEscape(&apos;&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;&apos;));</span><br><span class="line">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure><h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split() 方法"></a>split() 方法</h3><p>split() 方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。<br>split(字符串 或 RegExp 对象，指定数组大小)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colorText = &apos;red,blue,green&apos;;</span><br><span class="line">var color1 = colorText.split(&apos;,&apos;);      // [&apos;red&apos;,&apos;blue&apos;,&apos;green&apos;]</span><br><span class="line">var color2 = colorText.split(&apos;,&apos;, 2);   // [&apos;red&apos;,&apos;blue&apos;]</span><br></pre></td></tr></table></figure><h2 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare() 方法"></a>localeCompare() 方法</h2><p>localeCompare() 方法比较两个字符串。26 字母表作为比较标准。</p><ul><li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是 -1）</li><li>如果字符串等于字符串参数，则返回 0</li><li>如果字符串在字母表中应该排在字符串参数之后，则返回一个整数（大多数情况下是 1）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;yellow&apos;;</span><br><span class="line">alert(stringValue.localeCompare(&apos;brick&apos;));  // 1</span><br><span class="line">alert(stringValue.localeCompare(&apos;yellow&apos;)); // 0</span><br><span class="line">alert(stringValue.localeCompare(&apos;zoo&apos;));    // -1</span><br></pre></td></tr></table></figure><p>因为 localeCompare() 返回的数值取决于实现，所以最好是像下面例子所示使用该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = &apos;yellow&apos;;</span><br><span class="line"></span><br><span class="line">function determineOrder(value) &#123;</span><br><span class="line">    var result = stringValue.localeCompare(value);</span><br><span class="line">    if (result &lt; 0) &#123;</span><br><span class="line">        alert(&apos;yellow before&apos;+ value + &apos;&apos;)</span><br><span class="line">    &#125; else if (result &gt;0) &#123;</span><br><span class="line">        alert(&apos;yellow after&apos; + value + &apos;&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&apos;yellow equal&apos; + value + &apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">determineOrder(&apos;brick&apos;);</span><br><span class="line">determineOrder(&apos;yellow&apos;);</span><br><span class="line">determineOrder(&apos;zoo&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode() 方法"></a>fromCharCode() 方法</h2><p>string 构造函数本身还有一个静态方法： fromCharCode()。<br>这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。<br>从本质上来看，这个方法与实力方法 charCodeAt() 执行的是相反的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(String.fromCharCode(104, 101, 108, 108, 111)); // &apos;hello&apos;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Function 类型</title>
      <link href="/2017/11/18/Function%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/18/Function%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>函数实际上是对象，每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。<br>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明</span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数表达式定义了变量 sum 并将其初始化为一个函数。function 关键字后面没有函数名，这是因为在使用函数表达式定义函数时，没有必要使用函数名——通过变量 sum 即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。</p><p>由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同，即一个函数可能会有多个名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return sum1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(10,10));        // 20          </span><br><span class="line"></span><br><span class="line">var anontherSum = sum; // 不带括号的函数名是访问函数指针，而非调用函数</span><br><span class="line">alert(anotherSum(10,10)); // 20</span><br><span class="line"></span><br><span class="line">sum = null;</span><br><span class="line">alert(anotherSum(10,10)); // 20</span><br><span class="line">alert(sum(10,10));        // sum is not a function</span><br></pre></td></tr></table></figure><h2 id="JS-函数重载"><a href="#JS-函数重载" class="headerlink" title="JS 函数重载"></a>JS 函数重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// JS 函数重载</span><br><span class="line">function addMethod(object, name, fn) &#123;</span><br><span class="line">　　var old = object[name]; // 把前一次添加的方法存在一个临时变量 old 里面</span><br><span class="line"></span><br><span class="line">    // 重写了 object[name] 的方法</span><br><span class="line">　　object[name] = function() &#123;</span><br><span class="line">        // 如果调用 object[name] 方法时，传入的参数个数跟预期的一致，则直接调用</span><br><span class="line">　　　　if(fn.length === arguments.length) &#123;</span><br><span class="line">　　　　　　return fn.apply(this, arguments);</span><br><span class="line">        // 否则，判断 old 是否是函数，如果是，就调用 old</span><br><span class="line">　　　　&#125; else if(typeof old === &quot;function&quot;) &#123;</span><br><span class="line">　　　　　　return old.apply(this, arguments);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// Dean Edwards，Dean 是 first-name，Edwards 是 last-name</span><br><span class="line">var people = &#123;</span><br><span class="line">　　values: [&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * 通过 addMethod 来实现对 people.find 方法的重载</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">// 不传参数时，返回 peopld.values 里面的所有元素</span><br><span class="line">addMethod(people, &quot;find&quot;, function() &#123;</span><br><span class="line">　　return this.values;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 传一个参数时，按 first-name 的匹配进行返回</span><br><span class="line">addMethod(people, &quot;find&quot;, function(firstName) &#123;</span><br><span class="line">　　var ret = [];</span><br><span class="line">　　for(var i = 0; i &lt; this.values.length; i++) &#123;</span><br><span class="line">　　　　if(this.values[i].indexOf(firstName) === 0) &#123;</span><br><span class="line">　　　　　　ret.push(this.values[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return ret;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 传两个参数时，返回first-name和last-name都匹配的元素</span><br><span class="line">addMethod(people, &quot;find&quot;, function(firstName, lastName) &#123;</span><br><span class="line">　　var ret = [];</span><br><span class="line">　　for(var i = 0; i &lt; this.values.length; i++) &#123;</span><br><span class="line">　　　　if(this.values[i] === (firstName + &quot; &quot; + lastName)) &#123;</span><br><span class="line">　　　　　　ret.push(this.values[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return ret;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 测试：</span><br><span class="line">console.log(people.find()); //[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]</span><br><span class="line">console.log(people.find(&quot;Dean&quot;)); //[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]</span><br><span class="line">console.log(people.find(&quot;Dean Edwards&quot;)); //[&quot;Dean Edwards&quot;]</span><br></pre></td></tr></table></figure><h2 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h2><p>解析器会率先读取到函数声明，并使其在执行任何代码之前可用（可以访问）<br>函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明 （函数声明提升）</span><br><span class="line">alert(sum(10,10));</span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式 （error）</span><br><span class="line">alert(sum(10,10));</span><br><span class="line">var sum = function (num1 + num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码执行正常。因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。<br>对代码求值时，Javascript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。</p><h2 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h2><p>因为函数本身就是变量，所以函数可以作为值来使用。即将一个函数作为另一个函数的结果返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 第一个参数是函数，第二个参数是传递给该函数的一个值</span><br><span class="line">function callSomeFunction (someFunction, someArgument) &#123;</span><br><span class="line">    return someFunction(someArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add10 (num) &#123;</span><br><span class="line">    return num + 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result1 = callSomeFunction(add10, 10);</span><br><span class="line">alert(result1); // 20</span><br><span class="line"></span><br><span class="line">function getGreeting(name) &#123;</span><br><span class="line">    return &quot;Hello, &quot; + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result2 = callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class="line">alert(result2); // &quot;Hello, Nicholas&quot;</span><br></pre></td></tr></table></figure></p><p>也可以从一个函数中返回另一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 根据接收的属性名来创建一个比较函数</span><br><span class="line">function createComparisonFunction (propertyName) &#123;</span><br><span class="line">    return function (object1, object2) &#123;</span><br><span class="line">        var value1 = object1[propertyName];</span><br><span class="line">        var value2 = object2[propertyName];</span><br><span class="line"></span><br><span class="line">        if (value1 &lt; value2) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if (value1 &gt; value2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个两个对象的数组 data</span><br><span class="line">var data = [&#123;name: &apos;Zachary&apos;, age: 28&#125;, &#123;name: &apos;Nicholas&apos;, age: 29&#125;];</span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(&apos;name&apos;));</span><br><span class="line">alert(data[0].name); // Nicholas</span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(&apos;age&apos;));</span><br><span class="line">alert(data[0].name); // Zachary</span><br></pre></td></tr></table></figure><h2 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h2><p>在函数内部，有两个特殊的对象：arguments 和 this。</p><h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p>arguments 是一个类数组对象，包含传入函数中的所有参数，主要用途是保存函数参数，这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 阶乘函数,递归算法</span><br><span class="line">function factorial (num) &#123;</span><br><span class="line">    if (num &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * factorial(num-1) // 函数的执行与函数名 factorial 耦合在一起了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解除函数名耦合</span><br><span class="line">function factorial (num) &#123;</span><br><span class="line">    if (num &lt;= 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解除耦合应用</span><br><span class="line">var trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = function () &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(trueFactorial(5)); // 120</span><br><span class="line">alert(factorial(5));     // 0</span><br></pre></td></tr></table></figure><h3 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h3><p>this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是window）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123; color: &apos;blue&apos;&#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个函数，函数指针为名叫 sayColor 的变量</span><br><span class="line">function sayColor () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();   // red</span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor; // 将函数赋给对象 o</span><br><span class="line">o.sayColor(); // blue</span><br></pre></td></tr></table></figure><font style="color: red">注意：函数的名字仅仅是一个包含指针的变量而已</font><h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>caller 属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。<br>这个属性只有在函数执行时才有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// caller 返回的是调用当前函数的函数的引用</span><br><span class="line">function outer () &#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inner () &#123;</span><br><span class="line">    alert(inner.caller);</span><br><span class="line">    // alert(arguments.callee.caller); 解耦</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); // 弹出框显示 outer() 函数的源代码,即返回的是调用当前函数的函数的引用</span><br><span class="line">inner(); // null 直接调用，作用域为全局作用域，所以值为 null</span><br><span class="line"></span><br><span class="line">// callee 返回的是正在执行的函数本身的引用，是 arguments 的一个属性</span><br><span class="line">function outer () &#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inner () &#123;</span><br><span class="line">    alert(arguments.callee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); // 弹出框显示 inner() 函数的源代码,即返回的是正在执行的函数本身的引用</span><br><span class="line">inner(); // 弹出框显示 inner() 函数的源代码</span><br></pre></td></tr></table></figure><h3 id="callee"><a href="#callee" class="headerlink" title="callee"></a>callee</h3><p>callee 有一个 length 属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较 arguments.callee.length 是否等于 arguments.length。<br>这个属性只有在函数执行时才有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 实参，即在调用时传递给函数的参数。</span><br><span class="line">function a () &#123;</span><br><span class="line">    alert(arguments.length)</span><br><span class="line">&#125;</span><br><span class="line">a();  // 0 实参</span><br><span class="line">a(6); // 1 实参</span><br><span class="line"></span><br><span class="line">// 形参，是在定义函数名和函数体的时候使用的参数。形参是函数被调用时用于接收实参值的变量。</span><br><span class="line">function b () &#123;</span><br><span class="line">    alert(arguments.callee.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b();  // 0 形参</span><br><span class="line">b(6); // 0 形参</span><br><span class="line"></span><br><span class="line">function sayName (name) &#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sayName.arguments.callee.length); // Cannot read property &apos;callee&apos; of null</span><br><span class="line"></span><br><span class="line">function sayName (name) &#123;</span><br><span class="line">    alert(arguments.callee.length);</span><br><span class="line">&#125;</span><br><span class="line">sayName(); // 1 callee 这个属性只有在函数执行时才有效</span><br></pre></td></tr></table></figure><h2 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h2><p>ECMAScript 中的函数是对象，因此函数也有属性和方法。<br>每个函数都包含两个属性：length 和 prototype</p><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>length 属性表示函数希望接收的命名参数的个数，即形参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function sayName (name) &#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sayHi () &#123;</span><br><span class="line">    alert(&apos;hi&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sayName.length); // 1</span><br><span class="line">alert(sum.length);     // 2</span><br><span class="line">alert(sayHi.length);   // 0</span><br></pre></td></tr></table></figure><h3 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="prototype 属性"></a>prototype 属性</h3><p>每个函数都包含两个非继承而来的方法：apply() 和 call()。<br>这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值<br>这两个方法的作用相同，区别仅在于接收的参数的方式不同。</p><h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply() 方法"></a>apply() 方法</h3><p>apply() 方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。<br>其中第二个参数可以是 Array 的实例，也可以是 arguments 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum1 (num1, num2) &#123;</span><br><span class="line">    return sum.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum2 (num1, num2) &#123;</span><br><span class="line">    return sum.apply(this, [num1, num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(10,10)); // 20</span><br><span class="line">alert(callSum2(10,10)); // 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function sum (num1) &#123;</span><br><span class="line">    return num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum1 (num1, num2) &#123;</span><br><span class="line">    return sum.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(30,20)); // 30</span><br></pre></td></tr></table></figure><h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call() 方法"></a>call() 方法</h3><p>call() 方法，第一个参数是 this 值，另外一个时传递的所有参数列举</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">    return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callSum(num1, num2) &#123;</span><br><span class="line">    return sum.call(this, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum(10,10)); // 20</span><br></pre></td></tr></table></figure><p>至于是使用 apply() 还是 call()，完全取决于你采取哪种给函数传递参数的方式最方便。</p><p>其实 apply() 和 call() 真正强大的地方是能够扩充函数赖以运行的作用域。<br>使用 apply() 或 call() 来扩充作用域的最大好处，就是对象不需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123; color: &apos;blue&apos;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();            // red</span><br><span class="line"></span><br><span class="line">sayColor.call(this);   // red</span><br><span class="line">sayColor.call(window); // red</span><br><span class="line">sayColor.call(o);      // blue</span><br></pre></td></tr></table></figure></p><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind() 方法"></a>bind() 方法</h3><p>bind() 方法会创建一个函数的实例，其 this 值会被绑定到传给 bind() 函数的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123; color: &apos;blue&apos;&#125;;</span><br><span class="line"></span><br><span class="line">function sayColor () &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); // blue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegExp类型</title>
      <link href="/2017/11/16/RegExp%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/16/RegExp%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。<br>搜索模式可用于文本搜索和文本替换。<br>工作原理：通配符技术（比较常见的是查找文件）</p><h2 id="创建一个正则表达式（字面量形式）"><a href="#创建一个正则表达式（字面量形式）" class="headerlink" title="创建一个正则表达式（字面量形式）"></a>创建一个正则表达式（字面量形式）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = /pattern/flags;</span><br></pre></td></tr></table></figure><p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找以及反向引用。<br>每个正则表达式都可带一或多个标志（flags），用以标明正则表达式的行为。</p><p>正则表达式的匹配模式支持下列 3 个标志：</p><ul><li>g: 表示全局（global）模式，即模式将被应用于所有的字符串，而非在发现第一个匹配项时立即停止</li><li>i: 表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写</li><li>m: 表示多行（multiline）模式，即在到达一行文本末尾时还是继续查找下一行中是否存在于模式匹配的项</li></ul><p>因此，一个正则表达式就是一个模式与上述 3 个标志的组合体,如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 匹配字符串中所有 &quot;at&quot; 的实例</span><br><span class="line">var re = /at/g;</span><br><span class="line"></span><br><span class="line">// 匹配第一个 &quot;bat&quot; 或 &quot;cat&quot;，不区分大小写</span><br><span class="line">var re = /[bc]at/i;</span><br><span class="line"></span><br><span class="line">// 匹配所有以 &quot;at&quot; 结尾的 3 个字符的组合，不区分大小写</span><br><span class="line"> var re = /.at/gi;</span><br></pre></td></tr></table></figure><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。<br>正则表达式中的元字符包括：（ [ { \ ^ $ | ) ? * + . ] }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 匹配第一个 &quot;[bc]at&quot;，不区分大小写</span><br><span class="line">var re = /\[bc\]at/i; // 用 &quot;\&quot; 来对元字符进行转义</span><br><span class="line"></span><br><span class="line">// 匹配所有 &quot;.at&quot;，不区分大小写</span><br><span class="line">var re = /\.at/gi; // 用 &quot;\&quot; 来对元字符进行转义</span><br></pre></td></tr></table></figure><h2 id="创建一个正则表达式（RegExp-构造函数）"><a href="#创建一个正则表达式（RegExp-构造函数）" class="headerlink" title="创建一个正则表达式（RegExp 构造函数）"></a>创建一个正则表达式（RegExp 构造函数）</h2><p>RegExp 构造函数接收两个参数：一个是匹配的字符串模式，另一个是可选的标志字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 匹配第一个 &quot;bat&quot; 或 &quot;cat&quot;，不区分大小写</span><br><span class="line">var re = new RegExp(&apos;[bc]at&apos;, &apos;i&apos;); // 构造函数创建正则表达式</span><br><span class="line"></span><br><span class="line">// 匹配第一个 &quot;bat&quot; 或 &quot;cat&quot;，不区分大小写</span><br><span class="line">var re = new RegExp(/[bc]at/i);</span><br><span class="line"></span><br><span class="line">// ES5 不允许用正则时使用第二个参数</span><br><span class="line">var re = new RegExp(/[bc]at/, &apos;i&apos;);</span><br><span class="line">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span><br><span class="line"></span><br><span class="line">// ES6 允许使用，并且返回的结果会忽略正则表达式原有的修饰符，用传入的修饰符</span><br><span class="line">var re = new RegExp(/[bc]at/ig, &apos;i&apos;).flags; // &apos;i&apos;</span><br></pre></td></tr></table></figure><p>由于 RegExp 构造函数的模式参数是字符串，所以在某些情况下要对字符串进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是。<br>例如 \n （字符 \ 在字符串中通常被转义为 \，而在正则表达式字符串中就会变成 \\）</p><table><thead><tr><th>字面量模式</th><th>等价的字符串</th></tr></thead><tbody><tr><td>/[bc]at/</td><td>“\[bc\]at”</td></tr><tr><td>/.at/</td><td>“\.at”</td></tr><tr><td>/name\/age/</td><td>“name\/age”</td></tr><tr><td>/\d.\d{1,2}/</td><td>“\d.\d{1,2}”</td></tr><tr><td>/\w\hello\123/</td><td>“\w\\hello\\123”</td></tr></tbody></table><h2 id="RegExp-实例属性"><a href="#RegExp-实例属性" class="headerlink" title="RegExp 实例属性"></a>RegExp 实例属性</h2><p>RegExp 的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p><ul><li>global：布尔值，表示是否设置了 g 标志</li><li>ignoreCase：布尔值，表示是否设置了 i 标志</li><li>multiline： 布尔值，表示是否设置了 m 标志</li><li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起</li><li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var re = /\[bc\]at/i;</span><br><span class="line"></span><br><span class="line">alert(re.global);     // false</span><br><span class="line">alert(re.ignoreCase); // true</span><br><span class="line">alert(re.multiline);  // false</span><br><span class="line">alert(re.lastIndex);  // 0</span><br><span class="line">alert(re.source);     // &quot;\[bc\]at&quot; 字面量形式</span><br><span class="line"></span><br><span class="line">var re = new RegExp(&apos;\\[bc\\]at&apos;,&apos;i&apos;);</span><br><span class="line"></span><br><span class="line">alert(re.global);     // false</span><br><span class="line">alert(re.ignoreCase); // true</span><br><span class="line">alert(re.multiline);  // false</span><br><span class="line">alert(re.lastIndex);  // 0</span><br><span class="line">alert(re.source);     // &quot;\[bc\]at&quot; 字面量形式</span><br></pre></td></tr></table></figure><h2 id="RegExp-实例方法"><a href="#RegExp-实例方法" class="headerlink" title="RegExp 实例方法"></a>RegExp 实例方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>exec() 方法专门为捕获组而设计的。</p><p>exec()方法接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回 null。</p><p>返回的虽然是 Array 的实例，但是包含两个额外的属性：</p><ul><li>index 表示匹配项在字符串中的位置</li><li>input 表示应用正则表达式的字符串</li></ul><p>在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;mom and dad and baby&quot;;       // 应用模式的字符串</span><br><span class="line">var re = /mom( and dad( and baby)?)?/gi; // 模式</span><br><span class="line"></span><br><span class="line">var matches = re.exec(text);</span><br><span class="line">alert(matches.index); // 0  </span><br><span class="line">alert(matches.input); // &apos;mom and dad and baby&apos;</span><br><span class="line">alert(matches[0]);    // &apos;mom and dad and baby&apos;</span><br><span class="line">alert(matches[1]);    // &apos;and dad and baby&apos; 捕获组</span><br><span class="line">alert(matches[2]);    // &apos;and baby&apos; 捕获组</span><br></pre></td></tr></table></figure><p>上述例子中的模式包含两个捕获组。最内部的捕获组匹配 “and baby”，而包含它的捕获组匹配 “and dad” 或者 “and dad and baby”。</p><p>对于 exec() 而言，在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 始终返回第一个匹配项的信息。<br>而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;cat, bat, sat, fat&apos;;</span><br><span class="line">var re1 = /.at/;</span><br><span class="line"></span><br><span class="line">var matches = re1.exec(text);</span><br><span class="line">alert(matches.index); // 0</span><br><span class="line">alert(matches[0]); // cat</span><br><span class="line">alert(re1.lastIndex);  // 0 下一个匹配字符项的位置</span><br><span class="line"></span><br><span class="line">var matches = re1.exec(text);</span><br><span class="line">alert(matches.index); // 0</span><br><span class="line">alert(matches[0]); // cat</span><br><span class="line">alert(re1.lastIndex);  // 0</span><br><span class="line"></span><br><span class="line">var re2 = /.at/g;</span><br><span class="line"></span><br><span class="line">var matches = re2.exec(text);</span><br><span class="line">alert(matches.index); // 0</span><br><span class="line">alert(matches[0]); // cat</span><br><span class="line">alert(re2.lastIndex);  // 3</span><br><span class="line"></span><br><span class="line">var matches = re2.exec(text);</span><br><span class="line">alert(matches.index); // 5</span><br><span class="line">alert(matches[0]); // bat</span><br><span class="line">alert(re2.lastIndex);  // 8</span><br><span class="line"></span><br><span class="line">var matches = re2.exec(text);</span><br><span class="line">alert(matches.index); // 10</span><br><span class="line">alert(matches[0]); // sat</span><br><span class="line">alert(re2.lastIndex);  // 13</span><br></pre></td></tr></table></figure></p><p>注意： IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex 属性每次也会变化。 </p><h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>test() 方法接收一个字符串参数。<br>在模式与该参数匹配的情况下返回 true；否则，返回 false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;000-00-0000&apos;;</span><br><span class="line">var re = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line"></span><br><span class="line">if (re.test(text)) &#123;</span><br><span class="line">    alert(&apos;The pattern was matched&apos;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegExp 实例继承的 toLocaleString() 和 toString() 方法都会返回正则表示的字面量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp(&apos;\\[bc\\]at&apos;,&apos;gi&apos;);</span><br><span class="line">alert(re.toString());       // /\[bc\]at/gi</span><br><span class="line">alert(re.toLocaleString()); // /\[bc\]at/gi</span><br><span class="line">alert(re.valueOf());        // /\[bc\]at/gi 返回正则表达式本身</span><br></pre></td></tr></table></figure><h2 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h2><p>RegExp 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最后一次正则表达式操作而变化。这些属性可以通过长属性名和一个短属性名（Opera 是例外，它不支持短属性名）来访问。</p><table><thead><tr><th>长属性名</th><th>短属性名</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>$_</td><td>最近一次要匹配的字符串。Opera未实现此属性</td></tr><tr><td>lastMatch</td><td>$&amp;</td><td>最近一次的匹配项。Opera未实现此属性</td></tr><tr><td>lastParen</td><td>$+</td><td>最近一次匹配的捕获组。Opera未实现此属性</td></tr><tr><td>leftContext</td><td>$`</td><td>input 字符串中 lastMatch 之前的文本</td></tr><tr><td>rightContext</td><td>$’</td><td>Input 字符串中 lastMatch 之后的文本 </td></tr><tr><td>multiline</td><td>$*</td><td>布尔值，表示是否所有表达式都使用多行模式。IE 和 Opera 未实现此属性</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;this has been a short summer&apos;;</span><br><span class="line">var re = /(.)hort/g;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 注意：Opera 不支持 input、lastMatch、lastParen 和 multiline 属性</span><br><span class="line"> * IE 不支持 multiline 属性</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">if (re.test(text)) &#123;</span><br><span class="line">    alert(RegExp.input);        // this has been a short summer</span><br><span class="line">    alert(RegExp.leftContext);  // this has been a</span><br><span class="line">    alert(RegExp.rightContext); // summer</span><br><span class="line">    alert(RegExp.lastMatch);    // short</span><br><span class="line">    alert(RegExp.lastParen);    // s</span><br><span class="line">    alert(RegExp.multiline);    // false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 短属性名，因为不是有效的 ECMAScript 标识符</span><br><span class="line"> * 必须通过括号语法来访问</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">if (re.test(text)) &#123;</span><br><span class="line">    alert(RegExp.$_);    // this has been a short summer</span><br><span class="line">    alert(RegExp[&quot;$`&quot;]); // this has been a</span><br><span class="line">    alert(RegExp[&quot;$&apos;&quot;]); // summer</span><br><span class="line">    alert(RegExp[&quot;$&amp;&quot;]); // short </span><br><span class="line">    alert(RegExp[&quot;$+&quot;]); // s</span><br><span class="line">    alert(RegExp[&quot;$*&quot;]); // false</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码创建一个模式，匹配任何一个字符后跟 hort，而且把第一个字符放在了一个捕获组中。</p><p>除了上面介绍的几个属性之外，还有多达 9 个用于存储捕获组的构造函数属性。<br>访问这些属性的语言是 RegExp.$1 、RegExp.$2 ··· RegExp.$9，分别用于存储第一、第二······第九个匹配的捕获组。<br>在调用 exec() 或 test() 方法时，这些属性会被自动填充<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var text = &apos;this has been a short summer&apos;;</span><br><span class="line">var re = /(..)or(.)/g;</span><br><span class="line"></span><br><span class="line">if (re.test(text)) &#123;</span><br><span class="line">    alert(RegExp.$1); // sh</span><br><span class="line">    alert(RegExp.$2); // t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\w</td><td>匹配任何 ASCⅡ 单字符[a-zA-Z0-9]</td></tr><tr><td>\W</td><td>匹配任何 ASCⅡ 单字符之外的字符</td></tr><tr><td>\s</td><td>匹配任何 Unicode 空白符</td></tr><tr><td>\S</td><td>匹配任何 Unicode 空白符之外的字符</td></tr><tr><td>\d</td><td>匹配任何数字[0-9]</td></tr><tr><td>\D</td><td>匹配任何数之外的字符</td></tr><tr><td>[…]</td><td>匹配方括号中的所有字符</td></tr><tr><td>[^…]</td><td>匹配非方括号中的所有字符</td></tr></tbody></table><h3 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>{n}</td><td>匹配前一项 n 次</td></tr><tr><td>{n,}</td><td>匹配前一项至少一次，至多不限</td></tr><tr><td>{n,m}</td><td>匹配前一项至少 n 次，最多 m 次</td></tr><tr><td>{?}</td><td>匹配前一项 0 次或者 1 次</td></tr><tr><td>{+}</td><td>匹配前一项至少 1 次</td></tr><tr><td>{*}</td><td>匹配前一项 0 次或者多次</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td></tr><tr><td>.</td><td>匹配除换行符 \n 之外的任何单字符</td></tr><tr><td>l</td><td>指明两项之间的一个选择</td></tr></tbody></table><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串的开头</td></tr><tr><td>$</td><td>匹配字符串的结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>与 \b 相反，匹配一个非单词的边界</td></tr></tbody></table><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>(…)</td><td>将几个项目组合成一个单元</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Date类型</title>
      <link href="/2017/11/06/Date%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/11/06/Date%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Date 类型使用自 UTC（Coordinated Universal Time，国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数来保存日期的。</p><h2 id="创建一个日期对象"><a href="#创建一个日期对象" class="headerlink" title="创建一个日期对象"></a>创建一个日期对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var now = new Date(); // 自动获取当前日期和时间</span><br></pre></td></tr></table></figure><p>如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数，为了简化这个过程，ECMAScript 提供了两个方法：parse() 和 UTC()</p><h3 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h3><p>Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。<br>支持格式：</p><ul><li>“月/日/年”，如 6/13/2016</li><li>“英文月名 日，年”，如 July 12,2016</li><li>“英文星期几 英文月名 日 年 时：分：秒 时区”，如 Tue May 25 2016 00:00:00 GMT-0700</li><li>“YYYY-MM-DD HH:mm:ss”,如 2016-5-20 23:13:45</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 为 2016年5月25日创建一个日期对象</span><br><span class="line">var oneDate = new Date(Date.parse(&apos;May 25, 2016&apos;); // Wed May 25 2016 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">// 如果直接传字符串给 Date 构造函数，也会在后台调用 Date.parse()</span><br><span class="line">var oneDate = new Date(&apos;May 25, 2016&apos;); // Wed May 25 2016 00:00:00 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure><h3 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h3><p>如果参数没有提供月、日，则假设为1。如果省略其他参数，则统统假设为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// GMT 时间 2000年1月1日午夜零时</span><br><span class="line">var y2k = new Date(Date.UTC(2000, 0)); </span><br><span class="line"></span><br><span class="line">// GMT 时间 2005年5月5日下午5:55:55</span><br><span class="line">var allFives = new Date(Date.UTC(20015, 4, 5, 17, 55, 55));</span><br></pre></td></tr></table></figure><h3 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h3><p>Date.now() 方法表示调用这个方法时的日期和时间的毫秒数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 取得开始时间</span><br><span class="line">var start = Date.now(); // 1510761051657</span><br><span class="line"></span><br><span class="line">//  取得停止时间</span><br><span class="line">var stop = Date.now(); // 1510761078726</span><br><span class="line"></span><br><span class="line">result = stop - start; // 27069</span><br></pre></td></tr></table></figure></p><p>支持 Date.now() 方法的浏览器包括 IE9+、Firefox 3+、Opera 10.5 和 Chorme。<br>在不支持的浏览器中，使用 + 操作符获取 Date 对象的时间戳，也可以同样达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 取得开始时间</span><br><span class="line">var start = +new Date(); // 1510761051657</span><br><span class="line"></span><br><span class="line">//  取得停止时间</span><br><span class="line">var stop = +new Date(); // 1510761078726</span><br><span class="line"></span><br><span class="line">result = stop - start; // 27069</span><br></pre></td></tr></table></figure><h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><ul><li>toLocaleString() 按照浏览器设置的地区想适应的格式返回日期和时间</li><li>toString() 返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是 0 到 23）表示</li><li>valueOf() 返回日期和时间的毫秒数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var time = new Date(); // Thu Nov 16 2017 00:03:49 GMT+0800 (中国标准时间)</span><br><span class="line">// toLocaleString()</span><br><span class="line">time.toLocaleString(); // 2017/11/16 上午12:03:49</span><br><span class="line"></span><br><span class="line">// toString()</span><br><span class="line">time.toString(); // Thu Nov 16 2017 00:03:49 GMT+0800 (中国标准时间)</span><br><span class="line"></span><br><span class="line">// valueOf()</span><br><span class="line">time.valueOf(); // 1510761829841</span><br></pre></td></tr></table></figure><h3 id="valueOf-方法比较时间"><a href="#valueOf-方法比较时间" class="headerlink" title="valueOf() 方法比较时间"></a>valueOf() 方法比较时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 逻辑上 15 号要早于 16 号，但从毫秒数上来看，15 号是小于 16 号的。</span><br><span class="line">var date1 = new Date(&apos;2017-11-16&apos;);</span><br><span class="line">var date2 = new Date(&apos;2017-11-15&apos;);</span><br><span class="line"></span><br><span class="line">date1.valueOf(); // 1510790400000 date1 &gt; date2</span><br><span class="line">date2.valueOf(); // 1510704000000</span><br><span class="line">alert(date1 &lt; date2); // false</span><br><span class="line">alert(date1 &gt; date2); // true</span><br></pre></td></tr></table></figure><h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><ul><li>toDateString()——以特定于实现的格式显示星期几、月、日和年</li><li>toTimeString()——以特定于实现的格式显示时、分、秒和时区。</li><li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年</li><li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒</li><li>toUTCString()——以特定于实现的格式完整的 UTC 日期<br>PS:　以上字符串方法的输出因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</li></ul><h2 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getTime()</td><td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td></tr><tr><td>setTime(毫秒)</td><td>以毫秒数设置日期，会改变整个日期</td></tr><tr><td>getFullYear(年)</td><td>取得 4 位数的年份（如 2016）</td></tr><tr><td>setFullYear(年)</td><td>设置日期的年份。传入的年份值必须是 4 位数</td></tr><tr><td>getMonth(月)</td><td>返回日期中的月份，其中 0 表示一月，11 表示十二月</td></tr><tr><td>setMonth(月)</td><td>设置日期的月份。传入的月份值比如大于0，超过 11 则增加年份</td></tr><tr><td>getDate(日)</td><td>返回日期月份中的天数（1 到 31）</td></tr><tr><td>setDate(日)</td><td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份</td></tr><tr><td>getDay()</td><td>返回日期中星期的性情几（其中 0 表示星期日，6 表示星期六）</td></tr><tr><td>getHours(时)</td><td>返回日期中的小时数（0 到 23）</td></tr><tr><td>setHours(时)</td><td>设置日期中的小时数。传入的值超过了 23 则增加月份中的天数</td></tr><tr><td>getMinutes(分)</td><td>返回日期中的分钟数（0 到 59）</td></tr><tr><td>setMinutes(分)</td><td>设置日期中的分钟数。传入的值超过了 59 则增加小时数</td></tr><tr><td>getSeconds(秒)</td><td>返回日期中的秒数</td></tr><tr><td>setSeconds(秒)</td><td>设置日期中的秒数。传入的值超过了 59 则会增加分钟数</td></tr><tr><td>getMilliseconds(毫秒)</td><td>返回日期中的毫秒数</td></tr><tr><td>setMilliseconds(毫秒)</td><td>设置日期中的毫秒数。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组的方法</title>
      <link href="/2017/08/23/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2017/08/23/%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟栈方法和队列方法"><a href="#模拟栈方法和队列方法" class="headerlink" title="模拟栈方法和队列方法"></a>模拟栈方法和队列方法</h2><p>添加的都是返回数组的长度，删除的都是返回该删除的项<br>push()、pop()、shift()、unshift()、reverse()、sort()、spilce() 均会改变原数组</p><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种 LIFO（Last-In-First-Out，后进先出）的数据结构，后面插进的项先移出，即最新添加的项最早被移除<br>在栈中，项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置————栈的顶部<br>为此，ECMAScript 为数组专门提供了 push() 和 pop() 方法，以便实现类似栈的行为</p><p>push() 方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，并返回修改后数组的长度<br>pop()  方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;];</span><br><span class="line">var newArr = arr.push(&apos;black&apos;); // 推入一项</span><br><span class="line">alert(newArr); // 3</span><br><span class="line"></span><br><span class="line">var item = arr.pop();           // 取得最后一项</span><br><span class="line">alert(item);       // black</span><br><span class="line">alert(arr.length); // 2</span><br></pre></td></tr></table></figure><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>队列是一种 FIFO（First-In-First-Out，先进先出）的数据结构，先插进的项先移出，队列在列表的末端添加项，从列表的前端移除项，即<font color="#FF0033" size="+1">在数组的前端移除项，在数组末端添加项</font><br>数组提供了 push() 和 shift() 方法来实现类似队列的行为</p><p>push() 方法可以接收任意数量的参数，把它们逐个添加到数组的末尾，并返回修改后数组的长度<br>shift() 方法能够移除数组中的第一个项，减少数组的 length 值，并返回移除的项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;];</span><br><span class="line">var newArr = arr.push(&apos;black&apos;); // 推入一项</span><br><span class="line">alert(newArr); // 3</span><br><span class="line"></span><br><span class="line">var item = arr.shift();         // 取得第一项         </span><br><span class="line">alert(item);       // red</span><br><span class="line">alert(arr.length); // 2</span><br></pre></td></tr></table></figure><p>从相反方向模拟队列，即<font color="#FF0033" size="+1">在数组的前端添加项，从数组末端移除项</font></p><p>unshift() 方法能在数组前端添加任意个项并返回新数组的长度<br>pop() 方法从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;];</span><br><span class="line">var newArr = arr.unshift(&apos;black&apos;); // 推入一项</span><br><span class="line">alert(newArr); // 3</span><br><span class="line"></span><br><span class="line">var item = arr.pop();              // 取得最后一项</span><br><span class="line">alert(item);       // black</span><br><span class="line">alert(arr.length); // 2</span><br></pre></td></tr></table></figure><p><img src="/Images/array.jpg" alt="数组的栈和队列" title="栈和队列示意图"></p><h2 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h2><h3 id="reverse-方法反转数组项的顺序"><a href="#reverse-方法反转数组项的顺序" class="headerlink" title="reverse() 方法反转数组项的顺序"></a>reverse() 方法反转数组项的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">arr.reverse();</span><br><span class="line">alert(arr); // 4,3,2,1</span><br></pre></td></tr></table></figure><p>优缺点：非常直观，但是不够灵活</p><h3 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort() 方法"></a>sort() 方法</h3><p>默认情况下，sort() 方法按升序排列数组项——即最小的值位于前面，最大的值排再最后面，为了实现排序，sort() 方法会调用每个数组项的 toString() 转型方法，然后比较得到的字符串，以确定如何排序。即使数组中每一项都是数值，sort() 方法比较的也是字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0, 1, 5, 10, 15];</span><br><span class="line">arr.sort();</span><br><span class="line">alert(arr); // 0,1,10,15,5 字符按从左到右一一对应比较的</span><br></pre></td></tr></table></figure><font color="#FF0033" size="+1">在 JavaScript 中，字符串的比较，是字符按从左到右一一对应比较的</font><p>sort() 方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接受两个参数：<br>如果第一个参数应该位于第二个参数之前则返回一个负数，即升序<br>如果两个参数相等则返回0<br>如果第一个参数应该位于第二个参数之后则返回一个正数，即降序</p><p>举一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 升序</span><br><span class="line">function compare(x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 降序</span><br><span class="line">function compare(x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if (x &gt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果只是对 Number 类型排序，则可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 升序</span><br><span class="line">var arr = [0, 1, 5, 10, 15];</span><br><span class="line">arr.sort(function(x, y) &#123;</span><br><span class="line">    return x - y; // 负数</span><br><span class="line">&#125;);</span><br><span class="line">alert(arr); // 0,1,5,10,15</span><br><span class="line"></span><br><span class="line">// 降序</span><br><span class="line">var arr = [0, 1, 5, 10, 15];</span><br><span class="line">arr.sort(function(x, y) &#123;</span><br><span class="line">    return y - x; // 正数</span><br><span class="line">&#125;);</span><br><span class="line">alert(arr); // 15,10,5,1,0</span><br></pre></td></tr></table></figure><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="concat-连接数组，返回新数组"><a href="#concat-连接数组，返回新数组" class="headerlink" title="concat() 连接数组，返回新数组"></a>concat() 连接数组，返回新数组</h3><p>concat() 方法是基于当前数组中的所有项创建一个新数组<br>首先创建一个当前数组的副本，当接收到参数会添加到我这个副本的末尾，然后返回新构建的数组，如果没有接收到参数则只会返回复制的副本。<br>如果传递的参数是一或多个数组，则该方法会将每一项都添加到副本里面，返回新的数组</p><p>举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;, &apos;black&apos;];</span><br><span class="line">var newArr = arr.concat(&apos;yellow&apos;, [&apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">alert(arr);     // red,green,blue</span><br><span class="line">alert(newArr);  // red,green,black,yellow,blue</span><br></pre></td></tr></table></figure></p><h3 id="slice-基于当前数组一个或多个项返回一个新数组"><a href="#slice-基于当前数组一个或多个项返回一个新数组" class="headerlink" title="slice() 基于当前数组一个或多个项返回一个新数组"></a>slice() 基于当前数组一个或多个项返回一个新数组</h3><p>slice() 方法可以接受一或两个参数，即要返回项的起始和结束位置。<br>一个参数时：返回指定开始位置到数组末尾的所有项<br>两个参数时：返回起始和结束位置之间的项，但是不包括结束位置的项<br>注意：slice() 方法不会影响原来的数组，从 0 开始，如果结束位置小于起始位置，则返回空数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;, &apos;black&apos;, &apos;yellow&apos;, &apos;purple&apos;];</span><br><span class="line">var arr2 = arr.slice(1);    // [&apos;green&apos;, &apos;black&apos;, &apos;yellow&apos;, &apos;purple&apos;] </span><br><span class="line">var arr3 = arr.slice(1,4);  // [&apos;green&apos;, &apos;black&apos;, &apos;yellow&apos;]</span><br><span class="line"></span><br><span class="line">// 参数中有一个负数，则用数组的长度加上该数来确定位置</span><br><span class="line">var arr4 = arr.slice(-1);   // [&apos;purple&apos;]</span><br><span class="line">var arr5 = arr.slice(4);    // [&apos;purple&apos;]</span><br><span class="line">var arr6 = arr.slice(-2,-1) // [&apos;yellow&apos;]</span><br><span class="line">var arr7 = arr.slice(3,4)   // [&apos;yellow&apos;]</span><br><span class="line"></span><br><span class="line">// 结束位置小于起始位置，返回空数组</span><br><span class="line">var arr6 = arr.slice(-1,-3)</span><br></pre></td></tr></table></figure><h3 id="splice-主要用于向数组的中间插入项"><a href="#splice-主要用于向数组的中间插入项" class="headerlink" title="splice() 主要用于向数组的中间插入项"></a>splice() 主要用于向数组的中间插入项</h3><p>删除：splice(删除的第一项的位置、要删除的项数)，如 splice(0, 2)会删除数组中的前两项<br>插入：splice(起始位置、0、要插入的项)，如 splice(2, 0, ‘red’, ‘green’)<br>替换：splice(起始位置、要删除的项数、要插入的项)，如 splice(2, 1, ‘red’, ‘green’)<br>注意：splice() 方法始终都会返回一个数组，该数组包含从原数组中删除的项（如果没有删除任何项，则返回一个空数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 删除</span><br><span class="line">var arr = [&apos;red&apos;, &apos;green&apos;, &apos;black&apos;];</span><br><span class="line">var remove = arr.splice(0,1)</span><br><span class="line">console.log(arr);     // [&apos;green&apos;, &apos;black&apos;]</span><br><span class="line">console.log(remove);  // [&apos;red&apos;]</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">var insert = arr.splice(1, 0, &apos;yellow&apos;); // 指定位置的前面插入</span><br><span class="line">console.log(arr);     // [&apos;red&apos;, &apos;yellow&apos;, &apos;green&apos;, &apos;black&apos;]</span><br><span class="line">console.log(insert);  // []</span><br><span class="line"></span><br><span class="line">// 替换</span><br><span class="line">var replace = arr.splice(1, 1, &apos;yellow&apos;);</span><br><span class="line">console.log(arr);     // [&apos;red&apos;, &apos;yellow&apos;, &apos;black&apos;]</span><br><span class="line">console.log(replace); // [&apos;green&apos;]</span><br></pre></td></tr></table></figure><h2 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h2><p>indexOf() 和 lastIndexOf() 两个方法都接受两个参数：要查找的项和查找起始点位置的索引（可选）<br>其中 indexOf() 从数组开头（位置为 0）开始查找，lastIndexOf() 从数组尾部开始（位置为 0）向前查找<br>注意：这两个方法都返回要查找的项在数组中的位置，没有找到则返回 -1。匹配严格按照全等操作符<br>支持IE9+等主流浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line">alert(numbers.indexOf(4));        // 3</span><br><span class="line">alert(numbers.lastIndexOf(4));    // 5</span><br><span class="line"></span><br><span class="line">alert(numbers.indexOf(4, 4));     // 5 </span><br><span class="line">alert(numbers.lastIndexOf(4, 4)); // 3 </span><br><span class="line">// lastIndexOf 的索引值的判断跟 indexOf 的一样</span><br><span class="line">// 不同的是，确定索引值后 lastIndexOf 往左边数的出现的第一个为返回的位置，返回位置从左由0开始</span><br><span class="line">//                   而   indexOf   往右边数的出现的第一个为返回的位置，返回位置从左由0开始</span><br><span class="line"></span><br><span class="line">// 在比较第一个参数与数组中的每一项时，会使用全等操作符</span><br><span class="line">// 所以查找的项必须严格相等（就像使用 === 一样）</span><br><span class="line">var person = &#123; name: &quot;John&quot;&#125;;</span><br><span class="line">var people = [&#123; name: &quot;John&quot;&#125;];</span><br><span class="line"></span><br><span class="line">var morePeople = [person];</span><br><span class="line"></span><br><span class="line">alert(people.indexOf(person));     // -1</span><br><span class="line">alert(morePeople.indexOf(person)); // 0</span><br><span class="line">alert(morePeople.indexOf(people)); // -1</span><br></pre></td></tr></table></figure><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><p>ECMAScript 5 定义了5个迭代的方法，每个方法都接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象——影响 this 值（可选）<br>传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。<br>注：这些方法都不会修改数组中的包含的值，支持IE9+等主流浏览器</p><h3 id="every-对数组中的每一项运行给定函数，如果该函数对每一项都返回-true，则返回-true"><a href="#every-对数组中的每一项运行给定函数，如果该函数对每一项都返回-true，则返回-true" class="headerlink" title="every()  : 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true"></a>every()  : 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true</h3><h3 id="some-对数组中的每一项运行给定函数，如果该函数对任一项返回-true，则返回-true"><a href="#some-对数组中的每一项运行给定函数，如果该函数对任一项返回-true，则返回-true" class="headerlink" title="some()   : 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true"></a>some()   : 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line"></span><br><span class="line">var everyResult = numbers.every(function(item, index, array) &#123;</span><br><span class="line">    return (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(everyResult); // false</span><br><span class="line"></span><br><span class="line">var someResult = numbers.some(function(item, index, array) &#123;</span><br><span class="line">    return (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(someResult); // true</span><br></pre></td></tr></table></figure><h3 id="filter-对数组中的每一项运行给定函数，返回该函数会返回-true-的项组成的数组"><a href="#filter-对数组中的每一项运行给定函数，返回该函数会返回-true-的项组成的数组" class="headerlink" title="filter() : 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组"></a>filter() : 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line"></span><br><span class="line">var filterResult = numbers.filter(function(item, index, array)&#123;</span><br><span class="line">    return (item &gt; 2)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(filterResult); // [3,4,5,4,3]</span><br></pre></td></tr></table></figure><h3 id="forEach-对数组中的每一项运行给定函数。这个方法设有返回值"><a href="#forEach-对数组中的每一项运行给定函数。这个方法设有返回值" class="headerlink" title="forEach(): 对数组中的每一项运行给定函数。这个方法设有返回值"></a>forEach(): 对数组中的每一项运行给定函数。这个方法设有返回值</h3><p>这个方法设有返回值，本质上与使用 for 循环迭代数组一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line"></span><br><span class="line">var result = 0;</span><br><span class="line">numbers.forEach(function(item, index, array) &#123;</span><br><span class="line">    result += item;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result); // 25</span><br></pre></td></tr></table></figure></p><p>注意，在数组定义时省略的元素不会在 forEach 遍历时被列出，但是手动赋值为 undefined 的元素是会被列出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var numbers = Array(5);</span><br><span class="line">numbers[3] = &apos;3&apos;;</span><br><span class="line">console.log(numbers);</span><br><span class="line">numbers.forEach(function(item) &#123;</span><br><span class="line">    console.log(item); // 3 undefined</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var numbers = [1, undefined, 3];</span><br><span class="line">numbers.forEach(function(item) &#123;</span><br><span class="line">    console.log(item); // 1 undefined 3</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="map-对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组"><a href="#map-对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组" class="headerlink" title="map() : 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组"></a>map() : 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组</h3><p>这个方法适合创建包含的项与另一个数组一一对应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span><br><span class="line"></span><br><span class="line">var mapResult = numbers.map(function(item, index, array) &#123;</span><br><span class="line">    return item * 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(mapResult); // [2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure></p><h2 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h2><p>两个归并数组的方法： reduce() 和 reduceRight()，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。<br>reduce() 和 reduceRight() 接受两个参数：在每一项上调用的函数和作为归并基础的初始值（可选）。<br>调用的函数接受 4 个参数：前一个值、当前值、项的索引值和数组对象。</p><h3 id="reduce-方法从数组的第一项开始，逐个遍历到最后"><a href="#reduce-方法从数组的第一项开始，逐个遍历到最后" class="headerlink" title="reduce() 方法从数组的第一项开始，逐个遍历到最后"></a>reduce() 方法从数组的第一项开始，逐个遍历到最后</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var sum = values.reduce(function(prev, cur, index, array) &#123;</span><br><span class="line">    return prev + cur</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(sum); // 15</span><br></pre></td></tr></table></figure><h3 id="reduceRight-方法从数组的最后一项开始，向前遍历到第一项"><a href="#reduceRight-方法从数组的最后一项开始，向前遍历到第一项" class="headerlink" title="reduceRight() 方法从数组的最后一项开始，向前遍历到第一项"></a>reduceRight() 方法从数组的最后一项开始，向前遍历到第一项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">var sum = values.reduceRight(function(perv, cur, index, array) &#123;</span><br><span class="line">    return prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(sum); // 15</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2017/08/04/%E6%95%B0%E7%BB%84/"/>
      <url>/2017/08/04/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是一个对象的集合，里边的对象可以是不同类型的（字符串、数值、对象等）。<br>数组的每一个成员对象都有一个“下标”，用来表示它在数组中的位置，下标是从 0 开始的。</p><h2 id="创建数组方法一（-Array-构造函数）"><a href="#创建数组方法一（-Array-构造函数）" class="headerlink" title="创建数组方法一（ Array 构造函数）"></a>创建数组方法一（ Array 构造函数）</h2><p>1．定义一个空数组（以下 new 均可以省略）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure></p><p>2．定义时可指定有 n 个元素的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如果 n 不是整数将会报 RangeError: Invalid array length 错误</span><br><span class="line">var arr = new Array(n);</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">var arr = Array(n);</span><br></pre></td></tr></table></figure></p><p>注意： 创建的数组长度 n 必须为一个数字，否则，将会创建一个只有单个（所输入的）元素的数组</p><p>3．定义时可直接初始化数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="创建数组方法二（数组字面量表示法，常用）"><a href="#创建数组方法二（数组字面量表示法，常用）" class="headerlink" title="创建数组方法二（数组字面量表示法，常用）"></a>创建数组方法二（数组字面量表示法，常用）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</span><br><span class="line">var arr = [1.1, true, &quot;a&quot;];         // 3 个不同类型的元素</span><br><span class="line">var arr = [];                       // 创建一个空数组</span><br><span class="line">var arr = [1,2,]    // 这样会创建一个包含 2 或 3 项的数组，不要这样创建！</span><br><span class="line">var arr = [,,,,,];  // 这样会创建一个包含 5 或 6 项的数组，不要这样创建！</span><br><span class="line"></span><br><span class="line">var num = 100;</span><br><span class="line">var arr = [num, num+1, num+2]; // 数组中的值不一定要是常量，可以是任意的表达式</span><br></pre></td></tr></table></figure><p>注意： var arr = [4] 和 var arr = new Array(4) 是不等效的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [4];      // [4]             length: 1</span><br><span class="line">var arr2 = Array(4); // (4) [empty × 4] length: 4</span><br></pre></td></tr></table></figure></p><p>前者是指创建了一个包含 4 的数组，后者指的是数组长度为 4，<br>所以使用字面值(literal)的方式应该不仅仅是便捷，同时也不易踩坑</p><h2 id="读取和设置数组"><a href="#读取和设置数组" class="headerlink" title="读取和设置数组"></a>读取和设置数组</h2><p>数组名[下标] = 值<br>如果下标为负数或者大于下标数均为 undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 定义一个字符串数组</span><br><span class="line">alert(arr[0]);                      // 显示第一项</span><br><span class="line">arr[2] = &quot;black&quot;;                   // 修改第三项</span><br><span class="line">arr[3] = &quot;brown&quot;;                   // 新增第四项</span><br></pre></td></tr></table></figure><h2 id="数组的属性（length）"><a href="#数组的属性（length）" class="headerlink" title="数组的属性（length）"></a>数组的属性（length）</h2><p>用法：&lt;数组对象&gt; . length<br>返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一（即从 1 开始）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">var names = [];</span><br><span class="line">alert(arr.length);      // 3</span><br><span class="line">alert(names.length);    // 0</span><br></pre></td></tr></table></figure><p>length 特殊的用法：可以通过设置 length 值来从数组末尾删除项或添加新项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];   // 创建一个数组长度为3的数组</span><br><span class="line"></span><br><span class="line">//删除项</span><br><span class="line">arr.length = 2;     // 将数组长度改为2</span><br><span class="line">alert(arr[2]);      // undefined 第三项已经给删除了</span><br><span class="line"></span><br><span class="line">//增加项</span><br><span class="line">arr.length = 4;     // 将数组长度增加到4</span><br><span class="line">alert(arr[3]);      // undefined 增加了第四项，但是没有赋值</span><br></pre></td></tr></table></figure><p>length 属性的使用：因为索引值(下标)始终是 length-1，因此下一个新项的位置就是 length。每增加一项 length 属性都会自动更新以反映这一变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </span><br><span class="line">arr[arr.length] = &quot;black&quot;;</span><br><span class="line">arr[arr.length] = &quot;brown&quot;;</span><br></pre></td></tr></table></figure><h2 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h2><ul><li>toString() 将某个值转化为字符串的方法，数组内每个值以逗号分隔组成一个字符串</li><li>valueOf()  返回的是数组</li><li>toLocaleString() 同样返回字符串，不同的是，调用的是每一项的 toLocaleString() 方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">alert(arr.toString());  // red,blue,green</span><br><span class="line">alert(arr.valueOf());   // red,blue,green</span><br><span class="line">alert(arr);             // red,blue,green</span><br><span class="line"></span><br><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">console.log(arr.toString());  // red,blue,green</span><br><span class="line">console.log(arr.valueOf());   // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line">console.log(arr);             // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><span class="line"></span><br><span class="line">var person1 = &#123;</span><br><span class="line">    toLocaleString : function() &#123;</span><br><span class="line">        return &apos;Esyy&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    toString : function() &#123;</span><br><span class="line">        return &apos;John&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person2 = &#123;</span><br><span class="line">    toLocaleString : function() &#123;</span><br><span class="line">        return &apos;Gril&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    toString : function() &#123;</span><br><span class="line">        return &apos;Boy&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var people = [person1, person2];</span><br><span class="line">alert(people);                  // John,Boy</span><br><span class="line">alert(people.toString());       // John,Boy</span><br><span class="line">alert(people.toLocaleString()); // Esyy,Gril</span><br></pre></td></tr></table></figure><h2 id="延伸：alert-和-console-log-区别"><a href="#延伸：alert-和-console-log-区别" class="headerlink" title="延伸：alert 和 console.log 区别"></a>延伸：alert 和 console.log 区别</h2><h3 id="alert"><a href="#alert" class="headerlink" title="alert()"></a>alert()</h3><p>1．只能输出 string,如果 alert 填写的是对象则会自动调用 toString() 方法<br>2．不支持多个参数,只能输出第一个值</p><h3 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h3><p>1．可以打印任何类型的数据<br>2．支持多个参数的写法</p><h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><h3 id="1．instanceof-操作符"><a href="#1．instanceof-操作符" class="headerlink" title="1．instanceof 操作符"></a>1．instanceof 操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (value instanceof Array) &#123;</span><br><span class="line">    // 对数组执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性：instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那么实际上就存在两个以上不同的全局执行环境，那么使用 instanceof 操作符可能就无法得到理想的结果。</p><h3 id="2．ECMAScript-5-的-isArray-函数"><a href="#2．ECMAScript-5-的-isArray-函数" class="headerlink" title="2．ECMAScript 5 的 isArray 函数"></a>2．ECMAScript 5 的 isArray 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value)) &#123;</span><br><span class="line">    // 对数组执行某些操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line"></span><br><span class="line">if (Array.isArray(arr)) &#123;</span><br><span class="line">    return Array.isArray(arr);</span><br><span class="line">&#125;</span><br><span class="line">// JS 错误：SyntaxError: Illegal return statement</span><br></pre></td></tr></table></figure></p><p>原因是：<font color="#FF0033" size="+1">在 JS 中 return 语句只能放在 function 中，如果不是在一个 function 中弹出如上错误。</font></p><p>下面演示一下正确的打开姿势：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">    if (Array.isArray(arr)) &#123;</span><br><span class="line">        return Array.isArray(arr); // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性：只支持 IE9+、 Firefox 4+、Safari 5+、Opera 10.5+ 和 Chrome<br>那么 IE9 以下以及其他不兼容的浏览器怎么办，看看下面的原生方法</p><h3 id="3．-原生的-toString-方法"><a href="#3．-原生的-toString-方法" class="headerlink" title="3． 原生的 toString() 方法"></a>3． 原生的 toString() 方法</h3><p>在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [Object NativeConstructorName] 格式的字符串。<br>举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.toString.call(value)); // [object Array]</span><br></pre></td></tr></table></figure></p><p>因为原生数组的构造函数名与全局作用域无关，所以就可以用这个来创建一个检测数组的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isArray(value) &#123;</span><br><span class="line">    return Object.prototype.toString.call(value) == &apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font color="#FF0033" size="+1">注意：Object 的 toString() 方法不能检测非原生构造函数的构造函数名，且 Object.prototype.toString() 方法本身没有被修改过，是原生版本</font><p>因为开发人员定义的任何构造函数都将返回 [object Object]，所以有些 JavaScript 库会包含下面类似代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 检测原生 JSON 对象</span><br><span class="line">var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) == &apos;[object JSON]&apos;;</span><br><span class="line">console.log(isNativeJSON); // true</span><br></pre></td></tr></table></figure></p><h2 id="封装检测数组的通用方法"><a href="#封装检测数组的通用方法" class="headerlink" title="封装检测数组的通用方法"></a>封装检测数组的通用方法</h2><p>由于 Array.isArray() 是封装在浏览器中，运行效率比较高，所以当真正需要检测一个变量类型时，先会检测浏览器是否支持 Array.isArray(), 之后再用 Obejct.prototype.toString() 方法。<br>所以周全的封装的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </span><br><span class="line">function isArray(value) &#123;</span><br><span class="line">    if (typeof Array.isArray === &quot;function&quot;) &#123;</span><br><span class="line">        return Array.isArray(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Object.prototype.toString.call(value) === &quot;[object Array]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(isArray(arr));      // true</span><br></pre></td></tr></table></figure><h2 id="延伸：toString-方法来测试某个值是不是原生函数或正则表达式"><a href="#延伸：toString-方法来测试某个值是不是原生函数或正则表达式" class="headerlink" title="延伸：toString() 方法来测试某个值是不是原生函数或正则表达式"></a>延伸：toString() 方法来测试某个值是不是原生函数或正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 是否原生函数</span><br><span class="line">function isFunction(value) &#123;</span><br><span class="line">    return Object.prototype.toString.call(value) == &apos;[object Function]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否正则表达式</span><br><span class="line">function isRegExp(value) &#123;</span><br><span class="line">    return Object.prototype.toString.call(value) == &apos;[object RegExp]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3动画animation-timing-function中的cubic-bezier(n,n,n,n)</title>
      <link href="/2016/07/17/CSS3%E5%8A%A8%E7%94%BBanimation-timing-function%E4%B8%AD%E7%9A%84cubic-bezier(n,n,n,n)/"/>
      <url>/2016/07/17/CSS3%E5%8A%A8%E7%94%BBanimation-timing-function%E4%B8%AD%E7%9A%84cubic-bezier(n,n,n,n)/</url>
      
        <content type="html"><![CDATA[<p><img src="/Images/cubic-bezier.jpg" alt="贝兹曲线" title="贝兹曲线"><br>    <strong>Input Percentage(X),OutputPercentage(Y)</strong></p><h3 id="cubic-bezier即为贝兹曲线中的绘制方法："><a href="#cubic-bezier即为贝兹曲线中的绘制方法：" class="headerlink" title="cubic-bezier即为贝兹曲线中的绘制方法："></a>cubic-bezier即为贝兹曲线中的绘制方法：</h3><p>图上有四点，P0-3，其中P0、P3是默认的点，对应了[0,0], [1,1]。<br>P1、P2两点则是我们通过cubic-bezier()自定义的。<br>cubic-bezier(x1, y1, x2, y2) 为自定义，x1,x2,y1,y2的值范围在[0, 1]。</p><h3 id="预设的几个特效："><a href="#预设的几个特效：" class="headerlink" title="预设的几个特效："></a>预设的几个特效：</h3><p>ease(默认)： cubic-bezier(0.25， 0.1， 0.25， 1.0)       动画以低速开始，然后加快，在结束前变慢<br>linear：cubic-bezier(0， 0， 1.0， 1.0)       动画从头到尾的速度是相同的。<br>ease-in：cubic-bezier(0.42， 0， 1.0， 1.0)       动画以低速开始<br>ease-out：cubic-bezier(0， 0， 0.58， 1.0)        动画以低速结束<br>ease-in-out：cubic-bezier(0.42，0， 0.58， 1.0)  动画以低速开始和结束<br>所以（x1，y1）决定p1，（x2，y2）决定p2<br>即前两个数字决定P1位置，后两个数决定P2位置</p><h3 id="浏览器支持："><a href="#浏览器支持：" class="headerlink" title="浏览器支持："></a>浏览器支持：</h3><p>Internet Explorer 10、Firefox 以及 Opera 支持 animation-timing-function 属性。<br>Safari 和 Chrome 支持替代的 -webkit-animation-timing-function 属性。</p><p><strong>注意：Internet Explorer 9 以及更早的版本不支持 animation-timing-function 属性。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
